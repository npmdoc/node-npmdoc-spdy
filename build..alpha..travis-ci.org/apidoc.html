<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/indutny/node-spdy"

    >spdy (v3.4.4)</a>
</h1>
<h4>Implementation of the SPDY protocol on node.js.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy">module spdy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent">
            function <span class="apidocSignatureSpan">spdy.</span>Agent
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.super_">
            function <span class="apidocSignatureSpan">spdy.</span>Agent.super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer">
            function <span class="apidocSignatureSpan">spdy.</span>PlainServer
            <span class="apidocSignatureSpan">(options, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.super_">
            function <span class="apidocSignatureSpan">spdy.</span>PlainServer.super_
            <span class="apidocSignatureSpan">(requestListener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Server">
            function <span class="apidocSignatureSpan">spdy.</span>Server
            <span class="apidocSignatureSpan">(options, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Server.super_">
            function <span class="apidocSignatureSpan">spdy.</span>Server.super_
            <span class="apidocSignatureSpan">(opts, requestListener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket">
            function <span class="apidocSignatureSpan">spdy.</span>Socket
            <span class="apidocSignatureSpan">(parent, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_">
            function <span class="apidocSignatureSpan">spdy.</span>Socket.super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.agent.PlainAgent">
            function <span class="apidocSignatureSpan">spdy.</span>agent.PlainAgent
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.createAgent">
            function <span class="apidocSignatureSpan">spdy.</span>createAgent
            <span class="apidocSignatureSpan">(base, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.createServer">
            function <span class="apidocSignatureSpan">spdy.</span>createServer
            <span class="apidocSignatureSpan">(base, options, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle">
            function <span class="apidocSignatureSpan">spdy.</span>handle
            <span class="apidocSignatureSpan">(options, stream, socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_">
            function <span class="apidocSignatureSpan">spdy.</span>handle.super_
            <span class="apidocSignatureSpan">(stream, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">spdy.</span>Agent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">spdy.</span>Agent.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">spdy.</span>Agent.super_.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">spdy.</span>PlainServer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">spdy.</span>PlainServer.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">spdy.</span>PlainServer.super_.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">spdy.</span>Server.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">spdy.</span>Server.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">spdy.</span>Server.super_.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">spdy.</span>Socket.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">spdy.</span>Socket.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">spdy.</span>agent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">spdy.</span>agent.PlainAgent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">spdy.</span>handle.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">spdy.</span>handle.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">spdy.</span>request</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">spdy.</span>response</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">spdy.</span>server</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.Agent">module spdy.Agent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.Agent">
            function <span class="apidocSignatureSpan">spdy.</span>Agent
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.create">
            function <span class="apidocSignatureSpan">spdy.Agent.</span>create
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.super_">
            function <span class="apidocSignatureSpan">spdy.Agent.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.Agent.prototype">module spdy.Agent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.prototype._connect">
            function <span class="apidocSignatureSpan">spdy.Agent.prototype.</span>_connect
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.prototype._createSocket">
            function <span class="apidocSignatureSpan">spdy.Agent.prototype.</span>_createSocket
            <span class="apidocSignatureSpan">(req, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.prototype._createStream">
            function <span class="apidocSignatureSpan">spdy.Agent.prototype.</span>_createStream
            <span class="apidocSignatureSpan">(req, handle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.prototype._getCreateSocket">
            function <span class="apidocSignatureSpan">spdy.Agent.prototype.</span>_getCreateSocket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.prototype._init">
            function <span class="apidocSignatureSpan">spdy.Agent.prototype.</span>_init
            <span class="apidocSignatureSpan">(base, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.prototype.close">
            function <span class="apidocSignatureSpan">spdy.Agent.prototype.</span>close
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.prototype.createSocket">
            function <span class="apidocSignatureSpan">spdy.Agent.prototype.</span>createSocket
            <span class="apidocSignatureSpan">(req, options, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.Agent.super_">module spdy.Agent.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.super_.super_">
            function <span class="apidocSignatureSpan">spdy.Agent.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.Agent.super_.prototype">module spdy.Agent.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.super_.prototype._cacheSession">
            function <span class="apidocSignatureSpan">spdy.Agent.super_.prototype.</span>_cacheSession
            <span class="apidocSignatureSpan">(key, session)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.super_.prototype._evictSession">
            function <span class="apidocSignatureSpan">spdy.Agent.super_.prototype.</span>_evictSession
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.super_.prototype._getSession">
            function <span class="apidocSignatureSpan">spdy.Agent.super_.prototype.</span>_getSession
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.super_.prototype.createConnection">
            function <span class="apidocSignatureSpan">spdy.Agent.super_.prototype.</span>createConnection
            <span class="apidocSignatureSpan">(port, host, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.super_.prototype.getName">
            function <span class="apidocSignatureSpan">spdy.Agent.super_.prototype.</span>getName
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.Agent.super_.super_.prototype">module spdy.Agent.super_.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.super_.super_.prototype.addRequest">
            function <span class="apidocSignatureSpan">spdy.Agent.super_.super_.prototype.</span>addRequest
            <span class="apidocSignatureSpan">(req, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.super_.super_.prototype.createConnection">
            function <span class="apidocSignatureSpan">spdy.Agent.super_.super_.prototype.</span>createConnection
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.super_.super_.prototype.createSocket">
            function <span class="apidocSignatureSpan">spdy.Agent.super_.super_.prototype.</span>createSocket
            <span class="apidocSignatureSpan">(req, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.super_.super_.prototype.destroy">
            function <span class="apidocSignatureSpan">spdy.Agent.super_.super_.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.super_.super_.prototype.getName">
            function <span class="apidocSignatureSpan">spdy.Agent.super_.super_.prototype.</span>getName
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Agent.super_.super_.prototype.removeSocket">
            function <span class="apidocSignatureSpan">spdy.Agent.super_.super_.prototype.</span>removeSocket
            <span class="apidocSignatureSpan">(s, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.PlainServer">module spdy.PlainServer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.PlainServer">
            function <span class="apidocSignatureSpan">spdy.</span>PlainServer
            <span class="apidocSignatureSpan">(options, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.create">
            function <span class="apidocSignatureSpan">spdy.PlainServer.</span>create
            <span class="apidocSignatureSpan">(options, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.super_">
            function <span class="apidocSignatureSpan">spdy.PlainServer.</span>super_
            <span class="apidocSignatureSpan">(requestListener)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.PlainServer.prototype">module spdy.PlainServer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.prototype._handleConnection">
            function <span class="apidocSignatureSpan">spdy.PlainServer.prototype.</span>_handleConnection
            <span class="apidocSignatureSpan">(socket, protocol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.prototype._init">
            function <span class="apidocSignatureSpan">spdy.PlainServer.prototype.</span>_init
            <span class="apidocSignatureSpan">(base, options, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.prototype._invokeDefault">
            function <span class="apidocSignatureSpan">spdy.PlainServer.prototype.</span>_invokeDefault
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.prototype._onConnection">
            function <span class="apidocSignatureSpan">spdy.PlainServer.prototype.</span>_onConnection
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.prototype._onPlainConnection">
            function <span class="apidocSignatureSpan">spdy.PlainServer.prototype.</span>_onPlainConnection
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.prototype._onStream">
            function <span class="apidocSignatureSpan">spdy.PlainServer.prototype.</span>_onStream
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.prototype.emit">
            function <span class="apidocSignatureSpan">spdy.PlainServer.prototype.</span>emit
            <span class="apidocSignatureSpan">(event, req, res)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.PlainServer.super_">module spdy.PlainServer.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.super_.super_">
            function <span class="apidocSignatureSpan">spdy.PlainServer.</span>super_
            <span class="apidocSignatureSpan">(options, connectionListener)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.PlainServer.super_.prototype">module spdy.PlainServer.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.super_.prototype.setTimeout">
            function <span class="apidocSignatureSpan">spdy.PlainServer.super_.prototype.</span>setTimeout
            <span class="apidocSignatureSpan">(msecs, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.PlainServer.super_.super_.prototype">module spdy.PlainServer.super_.super_.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>listening</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.super_.super_.prototype._emitCloseIfDrained">
            function <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>_emitCloseIfDrained
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.super_.super_.prototype._listen2">
            function <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>_listen2
            <span class="apidocSignatureSpan">(address, port, addressType, backlog, fd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.super_.super_.prototype._setupSlave">
            function <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>_setupSlave
            <span class="apidocSignatureSpan">(socketList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.super_.super_.prototype.address">
            function <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>address
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.super_.super_.prototype.close">
            function <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.super_.super_.prototype.getConnections">
            function <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>getConnections
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.super_.super_.prototype.listen">
            function <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.super_.super_.prototype.listenFD">
            function <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>listenFD
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.super_.super_.prototype.ref">
            function <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>ref
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.PlainServer.super_.super_.prototype.unref">
            function <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>unref
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.Server">module spdy.Server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Server.Server">
            function <span class="apidocSignatureSpan">spdy.</span>Server
            <span class="apidocSignatureSpan">(options, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Server.create">
            function <span class="apidocSignatureSpan">spdy.Server.</span>create
            <span class="apidocSignatureSpan">(options, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Server.super_">
            function <span class="apidocSignatureSpan">spdy.Server.</span>super_
            <span class="apidocSignatureSpan">(opts, requestListener)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.Server.prototype">module spdy.Server.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Server.prototype._handleConnection">
            function <span class="apidocSignatureSpan">spdy.Server.prototype.</span>_handleConnection
            <span class="apidocSignatureSpan">(socket, protocol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Server.prototype._init">
            function <span class="apidocSignatureSpan">spdy.Server.prototype.</span>_init
            <span class="apidocSignatureSpan">(base, options, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Server.prototype._invokeDefault">
            function <span class="apidocSignatureSpan">spdy.Server.prototype.</span>_invokeDefault
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Server.prototype._onConnection">
            function <span class="apidocSignatureSpan">spdy.Server.prototype.</span>_onConnection
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Server.prototype._onPlainConnection">
            function <span class="apidocSignatureSpan">spdy.Server.prototype.</span>_onPlainConnection
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Server.prototype._onStream">
            function <span class="apidocSignatureSpan">spdy.Server.prototype.</span>_onStream
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Server.prototype.emit">
            function <span class="apidocSignatureSpan">spdy.Server.prototype.</span>emit
            <span class="apidocSignatureSpan">(event, req, res)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.Server.super_">module spdy.Server.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Server.super_.super_">
            function <span class="apidocSignatureSpan">spdy.Server.</span>super_
            <span class="apidocSignatureSpan">(options, listener)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.Server.super_.prototype">module spdy.Server.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Server.super_.prototype.setTimeout">
            function <span class="apidocSignatureSpan">spdy.Server.super_.prototype.</span>setTimeout
            <span class="apidocSignatureSpan">(msecs, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.Server.super_.super_.prototype">module spdy.Server.super_.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Server.super_.super_.prototype._getServerData">
            function <span class="apidocSignatureSpan">spdy.Server.super_.super_.prototype.</span>_getServerData
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Server.super_.super_.prototype._setServerData">
            function <span class="apidocSignatureSpan">spdy.Server.super_.super_.prototype.</span>_setServerData
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Server.super_.super_.prototype.addContext">
            function <span class="apidocSignatureSpan">spdy.Server.super_.super_.prototype.</span>addContext
            <span class="apidocSignatureSpan">(servername, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Server.super_.super_.prototype.getTicketKeys">
            function <span class="apidocSignatureSpan">spdy.Server.super_.super_.prototype.</span>getTicketKeys
            <span class="apidocSignatureSpan">(keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Server.super_.super_.prototype.setOptions">
            function <span class="apidocSignatureSpan">spdy.Server.super_.super_.prototype.</span>setOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Server.super_.super_.prototype.setTicketKeys">
            function <span class="apidocSignatureSpan">spdy.Server.super_.super_.prototype.</span>setTicketKeys
            <span class="apidocSignatureSpan">(keys)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.Socket">module spdy.Socket</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.Socket">
            function <span class="apidocSignatureSpan">spdy.</span>Socket
            <span class="apidocSignatureSpan">(parent, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_">
            function <span class="apidocSignatureSpan">spdy.Socket.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.Socket.prototype">module spdy.Socket.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.prototype.getCipher">
            function <span class="apidocSignatureSpan">spdy.Socket.prototype.</span>getCipher
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.prototype.getEphemeralKeyInfo">
            function <span class="apidocSignatureSpan">spdy.Socket.prototype.</span>getEphemeralKeyInfo
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.prototype.getPeerCertificate">
            function <span class="apidocSignatureSpan">spdy.Socket.prototype.</span>getPeerCertificate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.prototype.getSession">
            function <span class="apidocSignatureSpan">spdy.Socket.prototype.</span>getSession
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.prototype.getTLSTicket">
            function <span class="apidocSignatureSpan">spdy.Socket.prototype.</span>getTLSTicket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.prototype.isSessionReused">
            function <span class="apidocSignatureSpan">spdy.Socket.prototype.</span>isSessionReused
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.prototype.renegotiate">
            function <span class="apidocSignatureSpan">spdy.Socket.prototype.</span>renegotiate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.prototype.setMaxSendFragment">
            function <span class="apidocSignatureSpan">spdy.Socket.prototype.</span>setMaxSendFragment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.prototype.setServername">
            function <span class="apidocSignatureSpan">spdy.Socket.prototype.</span>setServername
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.prototype.setSession">
            function <span class="apidocSignatureSpan">spdy.Socket.prototype.</span>setSession
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.Socket.super_">module spdy.Socket.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.super_">
            function <span class="apidocSignatureSpan">spdy.Socket.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.Socket.super_.prototype">module spdy.Socket.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype._destroy">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>_destroy
            <span class="apidocSignatureSpan">(exception, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype._getpeername">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>_getpeername
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype._getsockname">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>_getsockname
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype._onTimeout">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>_onTimeout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype._read">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>_read
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype._unrefTimer">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>_unrefTimer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype._write">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>_write
            <span class="apidocSignatureSpan">(data, encoding, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype._writeGeneric">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>_writeGeneric
            <span class="apidocSignatureSpan">(writev, data, encoding, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype._writev">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>_writev
            <span class="apidocSignatureSpan">(chunks, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype.address">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>address
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype.connect">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>connect
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype.destroy">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>destroy
            <span class="apidocSignatureSpan">(exception)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype.destroySoon">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>destroySoon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype.end">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>end
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype.listen">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype.read">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>read
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype.ref">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>ref
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype.setKeepAlive">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>setKeepAlive
            <span class="apidocSignatureSpan">(setting, msecs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype.setNoDelay">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>setNoDelay
            <span class="apidocSignatureSpan">(enable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype.setTimeout">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>setTimeout
            <span class="apidocSignatureSpan">(msecs, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype.unref">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>unref
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.Socket.super_.prototype.write">
            function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>write
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.agent">module spdy.agent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.agent.Agent">
            function <span class="apidocSignatureSpan">spdy.agent.</span>Agent
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.agent.PlainAgent">
            function <span class="apidocSignatureSpan">spdy.agent.</span>PlainAgent
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.agent.create">
            function <span class="apidocSignatureSpan">spdy.agent.</span>create
            <span class="apidocSignatureSpan">(base, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.agent.PlainAgent">module spdy.agent.PlainAgent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.agent.PlainAgent.PlainAgent">
            function <span class="apidocSignatureSpan">spdy.agent.</span>PlainAgent
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.agent.PlainAgent.create">
            function <span class="apidocSignatureSpan">spdy.agent.PlainAgent.</span>create
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.agent.PlainAgent.super_">
            function <span class="apidocSignatureSpan">spdy.agent.PlainAgent.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.agent.PlainAgent.prototype">module spdy.agent.PlainAgent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.agent.PlainAgent.prototype._connect">
            function <span class="apidocSignatureSpan">spdy.agent.PlainAgent.prototype.</span>_connect
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.agent.PlainAgent.prototype._createSocket">
            function <span class="apidocSignatureSpan">spdy.agent.PlainAgent.prototype.</span>_createSocket
            <span class="apidocSignatureSpan">(req, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.agent.PlainAgent.prototype._createStream">
            function <span class="apidocSignatureSpan">spdy.agent.PlainAgent.prototype.</span>_createStream
            <span class="apidocSignatureSpan">(req, handle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.agent.PlainAgent.prototype._getCreateSocket">
            function <span class="apidocSignatureSpan">spdy.agent.PlainAgent.prototype.</span>_getCreateSocket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.agent.PlainAgent.prototype._init">
            function <span class="apidocSignatureSpan">spdy.agent.PlainAgent.prototype.</span>_init
            <span class="apidocSignatureSpan">(base, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.agent.PlainAgent.prototype.close">
            function <span class="apidocSignatureSpan">spdy.agent.PlainAgent.prototype.</span>close
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.agent.PlainAgent.prototype.createSocket">
            function <span class="apidocSignatureSpan">spdy.agent.PlainAgent.prototype.</span>createSocket
            <span class="apidocSignatureSpan">(req, options, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.handle">module spdy.handle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.handle">
            function <span class="apidocSignatureSpan">spdy.</span>handle
            <span class="apidocSignatureSpan">(options, stream, socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.create">
            function <span class="apidocSignatureSpan">spdy.handle.</span>create
            <span class="apidocSignatureSpan">(options, stream, socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_">
            function <span class="apidocSignatureSpan">spdy.handle.</span>super_
            <span class="apidocSignatureSpan">(stream, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.handle.prototype">module spdy.handle.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.prototype._closeCallback">
            function <span class="apidocSignatureSpan">spdy.handle.prototype.</span>_closeCallback
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.prototype._getPeerName">
            function <span class="apidocSignatureSpan">spdy.handle.prototype.</span>_getPeerName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.prototype._transformHeaders">
            function <span class="apidocSignatureSpan">spdy.handle.prototype.</span>_transformHeaders
            <span class="apidocSignatureSpan">(kind, headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.prototype.assignClientRequest">
            function <span class="apidocSignatureSpan">spdy.handle.prototype.</span>assignClientRequest
            <span class="apidocSignatureSpan">(req)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.prototype.assignRequest">
            function <span class="apidocSignatureSpan">spdy.handle.prototype.</span>assignRequest
            <span class="apidocSignatureSpan">(req)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.prototype.assignResponse">
            function <span class="apidocSignatureSpan">spdy.handle.prototype.</span>assignResponse
            <span class="apidocSignatureSpan">(res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.prototype.assignSocket">
            function <span class="apidocSignatureSpan">spdy.handle.prototype.</span>assignSocket
            <span class="apidocSignatureSpan">(socket, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.prototype.emitRequest">
            function <span class="apidocSignatureSpan">spdy.handle.prototype.</span>emitRequest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.prototype.emitResponse">
            function <span class="apidocSignatureSpan">spdy.handle.prototype.</span>emitResponse
            <span class="apidocSignatureSpan">(status, headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.prototype.getStream">
            function <span class="apidocSignatureSpan">spdy.handle.prototype.</span>getStream
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.handle.super_">module spdy.handle.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.super_">
            function <span class="apidocSignatureSpan">spdy.handle.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.create">
            function <span class="apidocSignatureSpan">spdy.handle.super_.</span>create
            <span class="apidocSignatureSpan">(stream, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">spdy.handle.super_.</span>mode</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.handle.super_.prototype">module spdy.handle.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.prototype._close">
            function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>_close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.prototype._flow">
            function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>_flow
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.prototype._pendingList">
            function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>_pendingList
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.prototype._queueReq">
            function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>_queueReq
            <span class="apidocSignatureSpan">(type, req)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.prototype._shutdown">
            function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>_shutdown
            <span class="apidocSignatureSpan">(wrap)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.prototype._writeEnc">
            function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>_writeEnc
            <span class="apidocSignatureSpan">(wrap, req, data, enc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.prototype.close">
            function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>close
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.prototype.getpeername">
            function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>getpeername
            <span class="apidocSignatureSpan">(out)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.prototype.getsockname">
            function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>getsockname
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.prototype.readStart">
            function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>readStart
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.prototype.readStop">
            function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>readStop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.prototype.setStream">
            function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>setStream
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.prototype.shutdown">
            function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>shutdown
            <span class="apidocSignatureSpan">(req)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.prototype.writeAsciiString">
            function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>writeAsciiString
            <span class="apidocSignatureSpan">(req, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.prototype.writeBinaryString">
            function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>writeBinaryString
            <span class="apidocSignatureSpan">(req, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.prototype.writeBuffer">
            function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>writeBuffer
            <span class="apidocSignatureSpan">(req, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.prototype.writeEnc">
            function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>writeEnc
            <span class="apidocSignatureSpan">(req, data, enc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.prototype.writeLatin1String">
            function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>writeLatin1String
            <span class="apidocSignatureSpan">(req, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.prototype.writeUcs2String">
            function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>writeUcs2String
            <span class="apidocSignatureSpan">(req, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.handle.super_.prototype.writeUtf8String">
            function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>writeUtf8String
            <span class="apidocSignatureSpan">(req, data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.request">module spdy.request</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.request.onNewListener">
            function <span class="apidocSignatureSpan">spdy.request.</span>onNewListener
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.response">module spdy.response</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.response.end">
            function <span class="apidocSignatureSpan">spdy.response.</span>end
            <span class="apidocSignatureSpan">(data, encoding, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.response.push">
            function <span class="apidocSignatureSpan">spdy.response.</span>push
            <span class="apidocSignatureSpan">(path, headers, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.response.writeContinue">
            function <span class="apidocSignatureSpan">spdy.response.</span>writeContinue
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.response.writeHead">
            function <span class="apidocSignatureSpan">spdy.response.</span>writeHead
            <span class="apidocSignatureSpan">(statusCode, reason, obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.spdy.server">module spdy.server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.server.PlainServer">
            function <span class="apidocSignatureSpan">spdy.server.</span>PlainServer
            <span class="apidocSignatureSpan">(options, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.server.Server">
            function <span class="apidocSignatureSpan">spdy.server.</span>Server
            <span class="apidocSignatureSpan">(options, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.spdy.server.create">
            function <span class="apidocSignatureSpan">spdy.server.</span>create
            <span class="apidocSignatureSpan">(base, options, handler)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy" id="apidoc.module.spdy">module spdy</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.Agent" id="apidoc.element.spdy.Agent">
        function <span class="apidocSignatureSpan">spdy.</span>Agent
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Agent(options) {
  this._init(base, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Agent.super_" id="apidoc.element.spdy.Agent.super_">
        function <span class="apidocSignatureSpan">spdy.</span>Agent.super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Agent(options) {
  http.Agent.call(this, options);
  this.defaultPort = 443;
  this.protocol = &#x27;https:&#x27;;
  this.maxCachedSessions = this.options.maxCachedSessions;
  if (this.maxCachedSessions === undefined)
    this.maxCachedSessions = 100;

  this._sessionCache = {
    map: {},
    list: []
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.PlainServer" id="apidoc.element.spdy.PlainServer">
        function <span class="apidocSignatureSpan">spdy.</span>PlainServer
        <span class="apidocSignatureSpan">(options, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(options, handler) {
  this._init(base, options, handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.PlainServer.super_" id="apidoc.element.spdy.PlainServer.super_">
        function <span class="apidocSignatureSpan">spdy.</span>PlainServer.super_
        <span class="apidocSignatureSpan">(requestListener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(requestListener) {
  if (!(this instanceof Server)) return new Server(requestListener);
  net.Server.call(this, { allowHalfOpen: true });

  if (requestListener) {
    this.addListener(&#x27;request&#x27;, requestListener);
  }

<span class="apidocCodeCommentSpan">  /* eslint-disable max-len */
</span>  // Similar option to this. Too lazy to write my own docs.
  // http://www.squid-cache.org/Doc/config/half_closed_clients/
  // http://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F
  /* eslint-enable max-len */
  this.httpAllowHalfOpen = false;

  this.addListener(&#x27;connection&#x27;, connectionListener);

  this.timeout = 2 * 60 * 1000;

  this._pendingResponseData = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Server" id="apidoc.element.spdy.Server">
        function <span class="apidocSignatureSpan">spdy.</span>Server
        <span class="apidocSignatureSpan">(options, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(options, handler) {
  this._init(base, options, handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Server.super_" id="apidoc.element.spdy.Server.super_">
        function <span class="apidocSignatureSpan">spdy.</span>Server.super_
        <span class="apidocSignatureSpan">(opts, requestListener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(opts, requestListener) {
  if (!(this instanceof Server)) return new Server(opts, requestListener);

  if (process.features.tls_npn &#x26;&#x26; !opts.NPNProtocols) {
    opts.NPNProtocols = [&#x27;http/1.1&#x27;, &#x27;http/1.0&#x27;];
  }

  if (process.features.tls_alpn &#x26;&#x26; !opts.ALPNProtocols) {
    // http/1.0 is not defined as Protocol IDs in IANA
    // http://www.iana.org/assignments/tls-extensiontype-values
    //       /tls-extensiontype-values.xhtml#alpn-protocol-ids
    opts.ALPNProtocols = [&#x27;http/1.1&#x27;];
  }

  tls.Server.call(this, opts, http._connectionListener);

  this.httpAllowHalfOpen = false;

  if (requestListener) {
    this.addListener(&#x27;request&#x27;, requestListener);
  }

  this.addListener(&#x27;tlsClientError&#x27;, function(err, conn) {
    if (!this.emit(&#x27;clientError&#x27;, err, conn))
      conn.destroy(err);
  });

  this.timeout = 2 * 60 * 1000;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket" id="apidoc.element.spdy.Socket">
        function <span class="apidocSignatureSpan">spdy.</span>Socket
        <span class="apidocSignatureSpan">(parent, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Socket(parent, options) {
  net.Socket.call(this, options);

  var state = {};

  this._spdyState = state;

  state.parent = parent;

  this.servername = parent.servername;
  this.npnProtocol = parent.npnProtocol;
  this.alpnProtocol = parent.alpnProtocol;
  this.authorized = parent.authorized;
  this.authorizationError = parent.authorizationError;
  this.encrypted = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var socketOptions = {
  handle: handle,
  allowHalfOpen: true
};

var socket;
if (state.secure)
  socket = new spdy.<span class="apidocCodeKeywordSpan">Socket</span>(state.socket, socketOptions);
else
  socket = new net.Socket(socketOptions);

handle.assignSocket(socket);
handle.assignClientRequest(req);

// Create stream only once `req.end()` is called
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_" id="apidoc.element.spdy.Socket.super_">
        function <span class="apidocSignatureSpan">spdy.</span>Socket.super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Socket(options) {
  if (!(this instanceof Socket)) return new Socket(options);

  this.connecting = false;
  this._hadError = false;
  this._handle = null;
  this._parent = null;
  this._host = null;

  if (typeof options === &#x27;number&#x27;)
    options = { fd: options }; // Legacy interface.
  else if (options === undefined)
    options = {};

  stream.Duplex.call(this, options);

  if (options.handle) {
    this._handle = options.handle; // private
  } else if (options.fd !== undefined) {
    this._handle = createHandle(options.fd);
    this._handle.open(options.fd);
    // options.fd can be string (since it user-defined),
    // so changing this to === would be semver-major
    // See: https://github.com/nodejs/node/pull/11513
    if ((options.fd == 1 || options.fd == 2) &#x26;&#x26;
        (this._handle instanceof Pipe) &#x26;&#x26;
        process.platform === &#x27;win32&#x27;) {
      // Make stdout and stderr blocking on Windows
      var err = this._handle.setBlocking(true);
      if (err)
        throw errnoException(err, &#x27;setBlocking&#x27;);
    }
    this.readable = options.readable !== false;
    this.writable = options.writable !== false;
  } else {
    // these will be set once there is a connection
    this.readable = this.writable = false;
  }

  // shut down the socket when we&#x27;re finished with it.
  this.on(&#x27;finish&#x27;, onSocketFinish);
  this.on(&#x27;_socketEnd&#x27;, onSocketEnd);

  initSocketHandle(this);

  this._pendingData = null;
  this._pendingEncoding = &#x27;&#x27;;

  // handle strings directly
  this._writableState.decodeStrings = false;

  // default to *not* allowing half open sockets
  this.allowHalfOpen = options &#x26;&#x26; options.allowHalfOpen || false;

  // if we have a handle, then start the flow of data into the
  // buffer.  if not, then this will happen when we connect
  if (this._handle &#x26;&#x26; options.readable !== false) {
    if (options.pauseOnCreate) {
      // stop the handle from reading and pause the stream
      this._handle.reading = false;
      this._handle.readStop();
      this._readableState.flowing = false;
    } else {
      this.read(0);
    }
  }

  // Reserve properties
  this.server = null;
  this._server = null;

  // Used after `.destroy()`
  this[BYTES_READ] = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.agent.PlainAgent" id="apidoc.element.spdy.agent.PlainAgent">
        function <span class="apidocSignatureSpan">spdy.</span>agent.PlainAgent
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Agent(options) {
  this._init(base, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.createAgent" id="apidoc.element.spdy.createAgent">
        function <span class="apidocSignatureSpan">spdy.</span>createAgent
        <span class="apidocSignatureSpan">(base, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(base, options) {
  if (typeof base === &#x27;object&#x27;) {
    options = base;
    base = null;
  }

  if (base)
    return instantiate(base).create(options);

  if (options.spdy &#x26;&#x26; options.spdy.plain)
    return exports.PlainAgent.create(options);
  else
    return exports.Agent.create(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Client:
```javascript
var spdy = require(&#x27;spdy&#x27;);
var http = require(&#x27;http&#x27;);

var agent = spdy.<span class="apidocCodeKeywordSpan">createAgent</span>({
host: &#x27;www.google.com&#x27;,
port: 443,

// Optional SPDY options
spdy: {
  plain: false or true,
  ssl: false or true,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.createServer" id="apidoc.element.spdy.createServer">
        function <span class="apidocSignatureSpan">spdy.</span>createServer
        <span class="apidocSignatureSpan">(base, options, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(base, options, handler) {
  if (typeof base === &#x27;object&#x27;) {
    handler = options;
    options = base;
    base = null;
  }

  if (base)
    return instantiate(base).create(options, handler);

  if (options.spdy &#x26;&#x26; options.spdy.plain)
    return exports.PlainServer.create(options, handler);
  else
    return exports.Server.create(options, handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

      // **optional** if true - server will send 3.1 frames on 3.0 *plain* spdy
      autoSpdy31: false
    }
  }
};

var server = spdy.<span class="apidocCodeKeywordSpan">createServer</span>(options, function(req, res) {
  res.writeHead(200);
  res.end(&#x27;hello world!&#x27;);
});

server.listen(3000);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle" id="apidoc.element.spdy.handle">
        function <span class="apidocSignatureSpan">spdy.</span>handle
        <span class="apidocSignatureSpan">(options, stream, socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Handle(options, stream, socket) {
  var state = {};
  this._spdyState = state;

  state.options = options || {};

  state.stream = stream;
  state.socket = null;
  state.rawSocket = socket || stream.connection.socket;
  state.deceiver = null;
  state.ending = false;

  var self = this;
  thing.call(this, stream, {
    getPeerName: function() {
      return self._getPeerName();
    },
    close: function(callback) {
      return self._closeCallback(callback);
    }
  });

  if (!state.stream) {
    this.on(&#x27;stream&#x27;, function(stream) {
      state.stream = stream;
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_" id="apidoc.element.spdy.handle.super_">
        function <span class="apidocSignatureSpan">spdy.</span>handle.super_
        <span class="apidocSignatureSpan">(stream, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Handle(stream, options) {
  EventEmitter.call(this);

  this._stream = stream;
  this._flowing = false;
  this._reading = false;
  this._options = options || {};

  this.onread = null;

  // Pending requests
  this.pending = new Queue();

  // Start handle once `onread` is set
  if (mode === &#x27;rusty&#x27;) {
    var self = this;
    Object.defineProperty(this, &#x27;onread&#x27;, {
      set: function(value) {
        Object.defineProperty(self, &#x27;onread&#x27;, {
          value: value
        });
        process.nextTick(function() {
          self.readStart();
        });
      }
    });
  }

  // NOTE: v0.8 has some odd .pause()/.resume() semantics in http.js
  if (mode === &#x27;rusty&#x27;)
    this.writeQueueSize = 0;
  else if (mode !== &#x27;modern&#x27;)
    this.writeQueueSize = 1;

  if (mode === &#x27;rusty&#x27;) {
    if (this._stream)
      this._rustyInit();
    else
      this.once(&#x27;stream&#x27;, this._rustyInit);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.Agent" id="apidoc.module.spdy.Agent">module spdy.Agent</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.Agent.Agent" id="apidoc.element.spdy.Agent.Agent">
        function <span class="apidocSignatureSpan">spdy.</span>Agent
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Agent(options) {
  this._init(base, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Agent.create" id="apidoc.element.spdy.Agent.create">
        function <span class="apidocSignatureSpan">spdy.Agent.</span>create
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(options) {
  return new Agent(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

server.listen(fixtures.port, function() {
  var socket = (plain ? net : tls).connect({
    rejectUnauthorized: false,
    port: fixtures.port,
    NPNProtocols: [ npn ]
  }, function() {
    client = transport.connection.<span class="apidocCodeKeywordSpan">create</span>(socket, {
      protocol: protocol,
      isServer: false
    });
    client.start(version);
    done();
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Agent.super_" id="apidoc.element.spdy.Agent.super_">
        function <span class="apidocSignatureSpan">spdy.Agent.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Agent(options) {
  http.Agent.call(this, options);
  this.defaultPort = 443;
  this.protocol = &#x27;https:&#x27;;
  this.maxCachedSessions = this.options.maxCachedSessions;
  if (this.maxCachedSessions === undefined)
    this.maxCachedSessions = 100;

  this._sessionCache = {
    map: {},
    list: []
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.Agent.prototype" id="apidoc.module.spdy.Agent.prototype">module spdy.Agent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.Agent.prototype._connect" id="apidoc.element.spdy.Agent.prototype._connect">
        function <span class="apidocSignatureSpan">spdy.Agent.prototype.</span>_connect
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _connect(options, callback) {
  var state = this._spdyState;

  var protocols = state.options.protocols || [
    &#x27;h2&#x27;,
    &#x27;spdy/3.1&#x27;, &#x27;spdy/3&#x27;, &#x27;spdy/2&#x27;,
    &#x27;http/1.1&#x27;, &#x27;http/1.0&#x27;
  ];

  // TODO(indutny): reconnect automatically?
  var socket = this.createConnection(util._extend({
    NPNProtocols: protocols,
    ALPNProtocols: protocols,
    servername: options.servername || options.host
  }, options));
  state.socket = socket;

  socket.setNoDelay(true);

  function onError(err) {
    return callback(err);
  }
  socket.on(&#x27;error&#x27;, onError);

  socket.on(state.secure ? &#x27;secureConnect&#x27; : &#x27;connect&#x27;, function() {
    socket.removeListener(&#x27;error&#x27;, onError);

    var protocol;
    if (state.secure) {
      protocol = socket.npnProtocol ||
                 socket.alpnProtocol ||
                 state.options.protocol;
    } else {
      protocol = state.options.protocol;
    }

    // HTTP server - kill socket and switch to the fallback mode
    if (!protocol || protocol === &#x27;http/1.1&#x27; || protocol === &#x27;http/1.0&#x27;) {
      debug(&#x27;activating fallback&#x27;);
      socket.destroy();
      state.fallback = true;
      return;
    }

    debug(&#x27;connected protocol=%j&#x27;, protocol);
    var connection = transport.connection.create(socket, util._extend({
      protocol: /spdy/.test(protocol) ? &#x27;spdy&#x27; : &#x27;http2&#x27;,
      isServer: false
    }, state.options.connection || {}));

    // Set version when we are certain
    if (protocol === &#x27;h2&#x27;) {
      connection.start(4);
    } else if (protocol === &#x27;spdy/3.1&#x27;) {
      connection.start(3.1);
    } else if (protocol === &#x27;spdy/3&#x27;) {
      connection.start(3);
    } else if (protocol === &#x27;spdy/2&#x27;) {
      connection.start(2);
    } else {
      socket.destroy();
      callback(new Error(&#x27;Unexpected protocol: &#x27; + protocol));
      return;
    }

    if (state.options[&#x27;x-forwarded-for&#x27;] !== undefined)
      connection.sendXForwardedFor(state.options[&#x27;x-forwarded-for&#x27;]);

    callback(null, connection);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  state.socket = null;
  state.connection = null;

  // No chunked encoding
  this.keepAlive = false;

  var self = this;
  this.<span class="apidocCodeKeywordSpan">_connect</span>(options, function(err, connection) {
    if (err)
      return self.emit(&#x27;error&#x27;, err);

    state.connection = connection;
    self.emit(&#x27;_connect&#x27;);
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Agent.prototype._createSocket" id="apidoc.element.spdy.Agent.prototype._createSocket">
        function <span class="apidocSignatureSpan">spdy.Agent.prototype.</span>_createSocket
        <span class="apidocSignatureSpan">(req, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _createSocket(req, options, callback) {
  var state = this._spdyState;
  if (state.fallback)
    return state.createSocket(req, options);

  var handle = spdy.handle.create(null, null, state.socket);

  var socketOptions = {
    handle: handle,
    allowHalfOpen: true
  };

  var socket;
  if (state.secure)
    socket = new spdy.Socket(state.socket, socketOptions);
  else
    socket = new net.Socket(socketOptions);

  handle.assignSocket(socket);
  handle.assignClientRequest(req);

  // Create stream only once `req.end()` is called
  var self = this;
  handle.once(&#x27;needStream&#x27;, function() {
    if (state.connection === null) {
      self.once(&#x27;_connect&#x27;, function() {
        handle.setStream(self._createStream(req, handle));
      });
    } else {
      handle.setStream(self._createStream(req, handle));
    }
  });

  // Yes, it is in reverse
  req.on(&#x27;response&#x27;, function(res) {
    handle.assignRequest(res);
  });
  handle.assignResponse(req);

  // Handle PUSH
  req.addListener(&#x27;newListener&#x27;, spdy.request.onNewListener);

  // For v0.8
  socket.readable = true;
  socket.writable = true;

  if (callback)
    return callback(null, socket);

  return socket;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  proto.createSocket = proto._createSocket;
} else {
  proto.createSocket = function createSocket(name, host, port, addr, req) {
    var state = this._spdyState;
    if (state.fallback)
      return state.createSocket(name, host, port, addr, req);

    return this.<span class="apidocCodeKeywordSpan">_createSocket</span>(req, {
      host: host,
      port: port
    });
  };
}

proto._createStream = function _createStream(req, handle) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Agent.prototype._createStream" id="apidoc.element.spdy.Agent.prototype._createStream">
        function <span class="apidocSignatureSpan">spdy.Agent.prototype.</span>_createStream
        <span class="apidocSignatureSpan">(req, handle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _createStream(req, handle) {
  var state = this._spdyState;

  var self = this;
  return state.connection.reserveStream({
    method: req.method,
    path: req.path,
    headers: req._headers,
    host: state.host
  }, function(err, stream) {
    if (err)
      return self.emit(&#x27;error&#x27;, err);

    stream.on(&#x27;response&#x27;, function(status, headers) {
      handle.emitResponse(status, headers);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
handle.assignClientRequest(req);

// Create stream only once `req.end()` is called
var self = this;
handle.once(&#x27;needStream&#x27;, function() {
  if (state.connection === null) {
    self.once(&#x27;_connect&#x27;, function() {
      handle.setStream(self.<span class="apidocCodeKeywordSpan">_createStream</span>(req, handle));
    });
  } else {
    handle.setStream(self._createStream(req, handle));
  }
});

// Yes, it is in reverse
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Agent.prototype._getCreateSocket" id="apidoc.element.spdy.Agent.prototype._getCreateSocket">
        function <span class="apidocSignatureSpan">spdy.Agent.prototype.</span>_getCreateSocket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _getCreateSocket() {
  // Find super&#x27;s `createSocket` method
  var createSocket;
  var cons = this.constructor.super_;
  do {
    createSocket = cons.prototype.createSocket;

    if (cons.super_ === EventEmitter || !cons.super_)
      break;
    cons = cons.super_;
  } while (!createSocket);
  if (!createSocket)
    createSocket = http.Agent.prototype.createSocket;

  assert(createSocket, &#x27;.createSocket() method not found&#x27;);

  return createSocket;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var state = {};
this._spdyState = state;

state.host = options.host;
state.options = options.spdy || {};
state.secure = this instanceof https.Agent;
state.fallback = false;
state.createSocket = this.<span class="apidocCodeKeywordSpan">_getCreateSocket</span>();
state.socket = null;
state.connection = null;

// No chunked encoding
this.keepAlive = false;

var self = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Agent.prototype._init" id="apidoc.element.spdy.Agent.prototype._init">
        function <span class="apidocSignatureSpan">spdy.Agent.prototype.</span>_init
        <span class="apidocSignatureSpan">(base, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _init(base, options) {
  base.call(this, options);

  var state = {};
  this._spdyState = state;

  state.host = options.host;
  state.options = options.spdy || {};
  state.secure = this instanceof https.Agent;
  state.fallback = false;
  state.createSocket = this._getCreateSocket();
  state.socket = null;
  state.connection = null;

  // No chunked encoding
  this.keepAlive = false;

  var self = this;
  this._connect(options, function(err, connection) {
    if (err)
      return self.emit(&#x27;error&#x27;, err);

    state.connection = connection;
    self.emit(&#x27;_connect&#x27;);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         /^v0\.12\./.test(process.version) ? &#x27;normal&#x27; :
         &#x27;modern&#x27;;

var proto = {};

function instantiate(base) {
function Agent(options) {
  this.<span class="apidocCodeKeywordSpan">_init</span>(base, options);
}
util.inherits(Agent, base);

Agent.create = function create(options) {
  return new Agent(options);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Agent.prototype.close" id="apidoc.element.spdy.Agent.prototype.close">
        function <span class="apidocSignatureSpan">spdy.Agent.prototype.</span>close
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function close(callback) {
  var state = this._spdyState;

  if (state.connection === null) {
    this.once(&#x27;_connect&#x27;, function() {
      this.close(callback);
    });
    return;
  }

  state.connection.end(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  agent: agent
}, function(response) {
  console.log(&#x27;yikes&#x27;);
  // Here it goes like with any other node.js HTTP request
  // ...
  // And once we&#x27;re done - we may close TCP connection to server
  // NOTE: All non-closed requests will die!
  agent.<span class="apidocCodeKeywordSpan">close</span>();
}).end();
```

Please note that if you use a custom agent, by default all connection-level
errors will result in an uncaught exception. To handle these errors subscribe
to the `error` event and re-emit the captured error:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Agent.prototype.createSocket" id="apidoc.element.spdy.Agent.prototype.createSocket">
        function <span class="apidocSignatureSpan">spdy.Agent.prototype.</span>createSocket
        <span class="apidocSignatureSpan">(req, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _createSocket(req, options, callback) {
  var state = this._spdyState;
  if (state.fallback)
    return state.createSocket(req, options);

  var handle = spdy.handle.create(null, null, state.socket);

  var socketOptions = {
    handle: handle,
    allowHalfOpen: true
  };

  var socket;
  if (state.secure)
    socket = new spdy.Socket(state.socket, socketOptions);
  else
    socket = new net.Socket(socketOptions);

  handle.assignSocket(socket);
  handle.assignClientRequest(req);

  // Create stream only once `req.end()` is called
  var self = this;
  handle.once(&#x27;needStream&#x27;, function() {
    if (state.connection === null) {
      self.once(&#x27;_connect&#x27;, function() {
        handle.setStream(self._createStream(req, handle));
      });
    } else {
      handle.setStream(self._createStream(req, handle));
    }
  });

  // Yes, it is in reverse
  req.on(&#x27;response&#x27;, function(res) {
    handle.assignRequest(res);
  });
  handle.assignResponse(req);

  // Handle PUSH
  req.addListener(&#x27;newListener&#x27;, spdy.request.onNewListener);

  // For v0.8
  socket.readable = true;
  socket.writable = true;

  if (callback)
    return callback(null, socket);

  return socket;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (cons.super_ === EventEmitter || !cons.super_)
    break;
  cons = cons.super_;
} while (!createSocket);
if (!createSocket)
  createSocket = http.Agent.prototype.createSocket;

assert(createSocket, &#x27;.<span class="apidocCodeKeywordSpan">createSocket</span>() method not found&#x27;);

return createSocket;
};

proto._connect = function _connect(options, callback) {
var state = this._spdyState;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.Agent.super_" id="apidoc.module.spdy.Agent.super_">module spdy.Agent.super_</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.Agent.super_.super_" id="apidoc.element.spdy.Agent.super_.super_">
        function <span class="apidocSignatureSpan">spdy.Agent.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Agent(options) {
  if (!(this instanceof Agent))
    return new Agent(options);

  EventEmitter.call(this);

  var self = this;

  self.defaultPort = 80;
  self.protocol = &#x27;http:&#x27;;

  self.options = util._extend({}, options);

  // don&#x27;t confuse net and make it think that we&#x27;re connecting to a pipe
  self.options.path = null;
  self.requests = {};
  self.sockets = {};
  self.freeSockets = {};
  self.keepAliveMsecs = self.options.keepAliveMsecs || 1000;
  self.keepAlive = self.options.keepAlive || false;
  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets;
  self.maxFreeSockets = self.options.maxFreeSockets || 256;

  self.on(&#x27;free&#x27;, function(socket, options) {
    var name = self.getName(options);
    debug(&#x27;agent.on(free)&#x27;, name);

    if (socket.writable &#x26;&#x26;
        self.requests[name] &#x26;&#x26; self.requests[name].length) {
      self.requests[name].shift().onSocket(socket);
      if (self.requests[name].length === 0) {
        // don&#x27;t leak
        delete self.requests[name];
      }
    } else {
      // If there are no pending requests, then put it in
      // the freeSockets pool, but only if we&#x27;re allowed to do so.
      var req = socket._httpMessage;
      if (req &#x26;&#x26;
          req.shouldKeepAlive &#x26;&#x26;
          socket.writable &#x26;&#x26;
          self.keepAlive) {
        var freeSockets = self.freeSockets[name];
        var freeLen = freeSockets ? freeSockets.length : 0;
        var count = freeLen;
        if (self.sockets[name])
          count += self.sockets[name].length;

        if (count &#x3e; self.maxSockets || freeLen &#x3e;= self.maxFreeSockets) {
          socket.destroy();
        } else {
          freeSockets = freeSockets || [];
          self.freeSockets[name] = freeSockets;
          socket.setKeepAlive(true, self.keepAliveMsecs);
          socket.unref();
          socket._httpMessage = null;
          self.removeSocket(socket, options);
          freeSockets.push(socket);
        }
      } else {
        socket.destroy();
      }
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.Agent.super_.prototype" id="apidoc.module.spdy.Agent.super_.prototype">module spdy.Agent.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.Agent.super_.prototype._cacheSession" id="apidoc.element.spdy.Agent.super_.prototype._cacheSession">
        function <span class="apidocSignatureSpan">spdy.Agent.super_.prototype.</span>_cacheSession
        <span class="apidocSignatureSpan">(key, session)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _cacheSession(key, session) {
  // Cache is disabled
  if (this.maxCachedSessions === 0)
    return;

  // Fast case - update existing entry
  if (this._sessionCache.map[key]) {
    this._sessionCache.map[key] = session;
    return;
  }

  // Put new entry
  if (this._sessionCache.list.length &#x3e;= this.maxCachedSessions) {
    const oldKey = this._sessionCache.list.shift();
    debug(&#x27;evicting %j&#x27;, oldKey);
    delete this._sessionCache.map[oldKey];
  }

  this._sessionCache.list.push(key);
  this._sessionCache.map[key] = session;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Agent.super_.prototype._evictSession" id="apidoc.element.spdy.Agent.super_.prototype._evictSession">
        function <span class="apidocSignatureSpan">spdy.Agent.super_.prototype.</span>_evictSession
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _evictSession(key) {
  const index = this._sessionCache.list.indexOf(key);
  if (index === -1)
    return;

  this._sessionCache.list.splice(index, 1);
  delete this._sessionCache.map[key];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Agent.super_.prototype._getSession" id="apidoc.element.spdy.Agent.super_.prototype._getSession">
        function <span class="apidocSignatureSpan">spdy.Agent.super_.prototype.</span>_getSession
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _getSession(key) {
  return this._sessionCache.map[key];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Agent.super_.prototype.createConnection" id="apidoc.element.spdy.Agent.super_.prototype.createConnection">
        function <span class="apidocSignatureSpan">spdy.Agent.super_.prototype.</span>createConnection
        <span class="apidocSignatureSpan">(port, host, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createConnection(port, host, options) {
  if (port !== null &#x26;&#x26; typeof port === &#x27;object&#x27;) {
    options = port;
  } else if (host !== null &#x26;&#x26; typeof host === &#x27;object&#x27;) {
    options = host;
  } else if (options === null || typeof options !== &#x27;object&#x27;) {
    options = {};
  }

  if (typeof port === &#x27;number&#x27;) {
    options.port = port;
  }

  if (typeof host === &#x27;string&#x27;) {
    options.host = host;
  }

  debug(&#x27;createConnection&#x27;, options);

  if (options._agentKey) {
    const session = this._getSession(options._agentKey);
    if (session) {
      debug(&#x27;reuse session for %j&#x27;, options._agentKey);
      options = util._extend({
        session: session
      }, options);
    }
  }

  const socket = tls.connect(options, () =&#x3e; {
    if (!options._agentKey)
      return;

    this._cacheSession(options._agentKey, socket.getSession());
  });

  // Evict session on error
  socket.once(&#x27;close&#x27;, (err) =&#x3e; {
    if (err)
      this._evictSession(options._agentKey);
  });

  return socket;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var protocols = state.options.protocols || [
  &#x27;h2&#x27;,
  &#x27;spdy/3.1&#x27;, &#x27;spdy/3&#x27;, &#x27;spdy/2&#x27;,
  &#x27;http/1.1&#x27;, &#x27;http/1.0&#x27;
];

// TODO(indutny): reconnect automatically?
var socket = this.<span class="apidocCodeKeywordSpan">createConnection</span>(util._extend({
  NPNProtocols: protocols,
  ALPNProtocols: protocols,
  servername: options.servername || options.host
}, options));
state.socket = socket;

socket.setNoDelay(true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Agent.super_.prototype.getName" id="apidoc.element.spdy.Agent.super_.prototype.getName">
        function <span class="apidocSignatureSpan">spdy.Agent.super_.prototype.</span>getName
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getName = function (options) {
  var name = http.Agent.prototype.getName.call(this, options);

  name += &#x27;:&#x27;;
  if (options.ca)
    name += options.ca;

  name += &#x27;:&#x27;;
  if (options.cert)
    name += options.cert;

  name += &#x27;:&#x27;;
  if (options.ciphers)
    name += options.ciphers;

  name += &#x27;:&#x27;;
  if (options.key)
    name += options.key;

  name += &#x27;:&#x27;;
  if (options.pfx)
    name += options.pfx;

  name += &#x27;:&#x27;;
  if (options.rejectUnauthorized !== undefined)
    name += options.rejectUnauthorized;

  name += &#x27;:&#x27;;
  if (options.servername &#x26;&#x26; options.servername !== options.host)
    name += options.servername;

  return name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.Agent.super_.super_.prototype" id="apidoc.module.spdy.Agent.super_.super_.prototype">module spdy.Agent.super_.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.Agent.super_.super_.prototype.addRequest" id="apidoc.element.spdy.Agent.super_.super_.prototype.addRequest">
        function <span class="apidocSignatureSpan">spdy.Agent.super_.super_.prototype.</span>addRequest
        <span class="apidocSignatureSpan">(req, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addRequest = function (req, options) {
  // Legacy API: addRequest(req, host, port, localAddress)
  if (typeof options === &#x27;string&#x27;) {
    options = {
      host: options,
      port: arguments[2],
      localAddress: arguments[3]
    };
  }

  options = util._extend({}, options);
  options = util._extend(options, this.options);

  if (!options.servername) {
    options.servername = options.host;
    const hostHeader = req.getHeader(&#x27;host&#x27;);
    if (hostHeader) {
      options.servername = hostHeader.replace(/:.*$/, &#x27;&#x27;);
    }
  }

  var name = this.getName(options);
  if (!this.sockets[name]) {
    this.sockets[name] = [];
  }

  var freeLen = this.freeSockets[name] ? this.freeSockets[name].length : 0;
  var sockLen = freeLen + this.sockets[name].length;

  if (freeLen) {
    // we have a free socket, so use that.
    var socket = this.freeSockets[name].shift();
    debug(&#x27;have free socket&#x27;);

    // don&#x27;t leak
    if (!this.freeSockets[name].length)
      delete this.freeSockets[name];

    socket.ref();
    req.onSocket(socket);
    this.sockets[name].push(socket);
  } else if (sockLen &#x3c; this.maxSockets) {
    debug(&#x27;call onSocket&#x27;, sockLen, freeLen);
    // If we are under maxSockets create a new one.
    this.createSocket(req, options, function(err, newSocket) {
      if (err) {
        process.nextTick(function() {
          req.emit(&#x27;error&#x27;, err);
        });
        return;
      }
      req.onSocket(newSocket);
    });
  } else {
    debug(&#x27;wait for socket&#x27;);
    // We are over limit so we&#x27;ll add it to the queue.
    if (!this.requests[name]) {
      this.requests[name] = [];
    }
    this.requests[name].push(req);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Agent.super_.super_.prototype.createConnection" id="apidoc.element.spdy.Agent.super_.super_.prototype.createConnection">
        function <span class="apidocSignatureSpan">spdy.Agent.super_.super_.prototype.</span>createConnection
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createConnection = function () {
  var args = new Array(arguments.length);
  for (var i = 0; i &#x3c; arguments.length; i++)
    args[i] = arguments[i];
  args = normalizeConnectArgs(args);
  debug(&#x27;createConnection&#x27;, args);
  var s = new Socket(args[0]);

  if (args[0].timeout) {
    s.setTimeout(args[0].timeout);
  }

  return Socket.prototype.connect.apply(s, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var protocols = state.options.protocols || [
  &#x27;h2&#x27;,
  &#x27;spdy/3.1&#x27;, &#x27;spdy/3&#x27;, &#x27;spdy/2&#x27;,
  &#x27;http/1.1&#x27;, &#x27;http/1.0&#x27;
];

// TODO(indutny): reconnect automatically?
var socket = this.<span class="apidocCodeKeywordSpan">createConnection</span>(util._extend({
  NPNProtocols: protocols,
  ALPNProtocols: protocols,
  servername: options.servername || options.host
}, options));
state.socket = socket;

socket.setNoDelay(true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Agent.super_.super_.prototype.createSocket" id="apidoc.element.spdy.Agent.super_.super_.prototype.createSocket">
        function <span class="apidocSignatureSpan">spdy.Agent.super_.super_.prototype.</span>createSocket
        <span class="apidocSignatureSpan">(req, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createSocket = function (req, options, cb) {
  var self = this;
  options = util._extend({}, options);
  options = util._extend(options, self.options);

  if (!options.servername) {
    options.servername = options.host;
    const hostHeader = req.getHeader(&#x27;host&#x27;);
    if (hostHeader) {
      options.servername = hostHeader.replace(/:.*$/, &#x27;&#x27;);
    }
  }

  var name = self.getName(options);
  options._agentKey = name;

  debug(&#x27;createConnection&#x27;, name, options);
  options.encoding = null;
  var called = false;
  const newSocket = self.createConnection(options, oncreate);
  if (newSocket)
    oncreate(null, newSocket);
  function oncreate(err, s) {
    if (called)
      return;
    called = true;
    if (err)
      return cb(err);
    if (!self.sockets[name]) {
      self.sockets[name] = [];
    }
    self.sockets[name].push(s);
    debug(&#x27;sockets&#x27;, name, self.sockets[name].length);

    function onFree() {
      self.emit(&#x27;free&#x27;, s, options);
    }
    s.on(&#x27;free&#x27;, onFree);

    function onClose(err) {
      debug(&#x27;CLIENT socket onClose&#x27;);
      // This is the only place where sockets get removed from the Agent.
      // If you want to remove a socket from the pool, just close it.
      // All socket errors end in a close event anyway.
      self.removeSocket(s, options);
    }
    s.on(&#x27;close&#x27;, onClose);

    function onRemove() {
      // We need this function for cases like HTTP &#x27;upgrade&#x27;
      // (defined by WebSockets) where we need to remove a socket from the
      // pool because it&#x27;ll be locked up indefinitely
      debug(&#x27;CLIENT socket onRemove&#x27;);
      self.removeSocket(s, options);
      s.removeListener(&#x27;close&#x27;, onClose);
      s.removeListener(&#x27;free&#x27;, onFree);
      s.removeListener(&#x27;agentRemove&#x27;, onRemove);
    }
    s.on(&#x27;agentRemove&#x27;, onRemove);
    cb(null, s);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (cons.super_ === EventEmitter || !cons.super_)
    break;
  cons = cons.super_;
} while (!createSocket);
if (!createSocket)
  createSocket = http.Agent.prototype.createSocket;

assert(createSocket, &#x27;.<span class="apidocCodeKeywordSpan">createSocket</span>() method not found&#x27;);

return createSocket;
};

proto._connect = function _connect(options, callback) {
var state = this._spdyState;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Agent.super_.super_.prototype.destroy" id="apidoc.element.spdy.Agent.super_.super_.prototype.destroy">
        function <span class="apidocSignatureSpan">spdy.Agent.super_.super_.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
  var sets = [this.freeSockets, this.sockets];
  for (var s = 0; s &#x3c; sets.length; s++) {
    var set = sets[s];
    var keys = Object.keys(set);
    for (var v = 0; v &#x3c; keys.length; v++) {
      var setName = set[keys[v]];
      for (var n = 0; n &#x3c; setName.length; n++) {
        setName[n].destroy();
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      client.start(version);
      done();
    });
  });
});

afterEach(function(done) {
  client.socket.<span class="apidocCodeKeywordSpan">destroy</span>();
  server.close(done);
});

it(&#x27;should process GET request&#x27;, function(done) {
  var stream = client.request({
    method: &#x27;GET&#x27;,
    path: &#x27;/get&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Agent.super_.super_.prototype.getName" id="apidoc.element.spdy.Agent.super_.super_.prototype.getName">
        function <span class="apidocSignatureSpan">spdy.Agent.super_.super_.prototype.</span>getName
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getName = function (options) {
  var name = options.host || &#x27;localhost&#x27;;

  name += &#x27;:&#x27;;
  if (options.port)
    name += options.port;

  name += &#x27;:&#x27;;
  if (options.localAddress)
    name += options.localAddress;

  // Pacify parallel/test-http-agent-getname by only appending
  // the &#x27;:&#x27; when options.family is set.
  if (options.family === 4 || options.family === 6)
    name += &#x27;:&#x27; + options.family;

  return name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Agent.super_.super_.prototype.removeSocket" id="apidoc.element.spdy.Agent.super_.super_.prototype.removeSocket">
        function <span class="apidocSignatureSpan">spdy.Agent.super_.super_.prototype.</span>removeSocket
        <span class="apidocSignatureSpan">(s, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeSocket = function (s, options) {
  var name = this.getName(options);
  debug(&#x27;removeSocket&#x27;, name, &#x27;writable:&#x27;, s.writable);
  var sets = [this.sockets];

  // If the socket was destroyed, remove it from the free buffers too.
  if (!s.writable)
    sets.push(this.freeSockets);

  for (var sk = 0; sk &#x3c; sets.length; sk++) {
    var sockets = sets[sk];

    if (sockets[name]) {
      var index = sockets[name].indexOf(s);
      if (index !== -1) {
        sockets[name].splice(index, 1);
        // Don&#x27;t leak
        if (sockets[name].length === 0)
          delete sockets[name];
      }
    }
  }

  if (this.requests[name] &#x26;&#x26; this.requests[name].length) {
    debug(&#x27;removeSocket, have a request, make a socket&#x27;);
    var req = this.requests[name][0];
    // If we have pending requests and a socket gets closed make a new one
    this.createSocket(req, options, function(err, newSocket) {
      if (err) {
        process.nextTick(function() {
          req.emit(&#x27;error&#x27;, err);
        });
        return;
      }
      newSocket.emit(&#x27;free&#x27;);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.PlainServer" id="apidoc.module.spdy.PlainServer">module spdy.PlainServer</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.PlainServer.PlainServer" id="apidoc.element.spdy.PlainServer.PlainServer">
        function <span class="apidocSignatureSpan">spdy.</span>PlainServer
        <span class="apidocSignatureSpan">(options, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(options, handler) {
  this._init(base, options, handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.PlainServer.create" id="apidoc.element.spdy.PlainServer.create">
        function <span class="apidocSignatureSpan">spdy.PlainServer.</span>create
        <span class="apidocSignatureSpan">(options, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(options, handler) {
  return new Server(options, handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

server.listen(fixtures.port, function() {
  var socket = (plain ? net : tls).connect({
    rejectUnauthorized: false,
    port: fixtures.port,
    NPNProtocols: [ npn ]
  }, function() {
    client = transport.connection.<span class="apidocCodeKeywordSpan">create</span>(socket, {
      protocol: protocol,
      isServer: false
    });
    client.start(version);
    done();
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.PlainServer.super_" id="apidoc.element.spdy.PlainServer.super_">
        function <span class="apidocSignatureSpan">spdy.PlainServer.</span>super_
        <span class="apidocSignatureSpan">(requestListener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(requestListener) {
  if (!(this instanceof Server)) return new Server(requestListener);
  net.Server.call(this, { allowHalfOpen: true });

  if (requestListener) {
    this.addListener(&#x27;request&#x27;, requestListener);
  }

<span class="apidocCodeCommentSpan">  /* eslint-disable max-len */
</span>  // Similar option to this. Too lazy to write my own docs.
  // http://www.squid-cache.org/Doc/config/half_closed_clients/
  // http://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F
  /* eslint-enable max-len */
  this.httpAllowHalfOpen = false;

  this.addListener(&#x27;connection&#x27;, connectionListener);

  this.timeout = 2 * 60 * 1000;

  this._pendingResponseData = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.PlainServer.prototype" id="apidoc.module.spdy.PlainServer.prototype">module spdy.PlainServer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.PlainServer.prototype._handleConnection" id="apidoc.element.spdy.PlainServer.prototype._handleConnection">
        function <span class="apidocSignatureSpan">spdy.PlainServer.prototype.</span>_handleConnection
        <span class="apidocSignatureSpan">(socket, protocol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _handleConnection(socket, protocol) {
  var state = this._spdyState;

  if (!protocol)
    protocol = state.options.protocol;

  debug(&#x27;incoming socket protocol=%j&#x27;, protocol);

  // No way we can do anything with the socket
  if (!protocol || protocol === &#x27;http/1.1&#x27; || protocol === &#x27;http/1.0&#x27;) {
    debug(&#x27;to default handler it goes&#x27;);
    return this._invokeDefault(socket);
  }

  socket.setNoDelay(true);

  var connection = transport.connection.create(socket, util._extend({
    protocol: /spdy/.test(protocol) ? &#x27;spdy&#x27; : &#x27;http2&#x27;,
    isServer: true
  }, state.options.connection || {}));

  // Set version when we are certain
  if (protocol === &#x27;http2&#x27;)
    connection.start(4);
  else if (protocol === &#x27;spdy/3.1&#x27;)
    connection.start(3.1);
  else if (protocol === &#x27;spdy/3&#x27;)
    connection.start(3);
  else if (protocol === &#x27;spdy/2&#x27;)
    connection.start(2);

  connection.on(&#x27;error&#x27;, function() {
    socket.destroy();
  });

  var self = this;
  connection.on(&#x27;stream&#x27;, function(stream) {
    self._onStream(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
proto._onConnection = function _onConnection(socket) {
var state = this._spdyState;

var protocol;
if (state.secure)
  protocol = socket.npnProtocol || socket.alpnProtocol;

this.<span class="apidocCodeKeywordSpan">_handleConnection</span>(socket, protocol);
};

proto._handleConnection = function _handleConnection(socket, protocol) {
var state = this._spdyState;

if (!protocol)
  protocol = state.options.protocol;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.PlainServer.prototype._init" id="apidoc.element.spdy.PlainServer.prototype._init">
        function <span class="apidocSignatureSpan">spdy.PlainServer.prototype.</span>_init
        <span class="apidocSignatureSpan">(base, options, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _init(base, options, handler) {
  var state = {};
  this._spdyState = state;

  state.options = options.spdy || {};

  var protocols = state.options.protocols || [
    &#x27;h2&#x27;,
    &#x27;spdy/3.1&#x27;, &#x27;spdy/3&#x27;, &#x27;spdy/2&#x27;,
    &#x27;http/1.1&#x27;, &#x27;http/1.0&#x27;
  ];

  var actualOptions = util._extend({
    NPNProtocols: protocols,

    // Future-proof
    ALPNProtocols: protocols
  }, options);

  state.secure = this instanceof tls.Server;

  if (state.secure)
    base.call(this, actualOptions);
  else
    base.call(this);

  // Support HEADERS+FIN
  this.httpAllowHalfOpen = true;

  var event = state.secure ? &#x27;secureConnection&#x27; : &#x27;connection&#x27;;

  state.listeners = this.listeners(event).slice();
  assert(state.listeners.length &#x3e; 0, &#x27;Server does not have default listeners&#x27;);
  this.removeAllListeners(event);

  if (state.options.plain)
    this.on(event, this._onPlainConnection);
  else
    this.on(event, this._onConnection);

  if (handler)
    this.on(&#x27;request&#x27;, handler);

  debug(&#x27;server init secure=%d&#x27;, state.secure);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         /^v0\.12\./.test(process.version) ? &#x27;normal&#x27; :
         &#x27;modern&#x27;;

var proto = {};

function instantiate(base) {
function Agent(options) {
  this.<span class="apidocCodeKeywordSpan">_init</span>(base, options);
}
util.inherits(Agent, base);

Agent.create = function create(options) {
  return new Agent(options);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.PlainServer.prototype._invokeDefault" id="apidoc.element.spdy.PlainServer.prototype._invokeDefault">
        function <span class="apidocSignatureSpan">spdy.PlainServer.prototype.</span>_invokeDefault
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _invokeDefault(socket) {
  var state = this._spdyState;

  for (var i = 0; i &#x3c; state.listeners.length; i++)
    state.listeners[i].call(this, socket);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  protocol = state.options.protocol;

debug(&#x27;incoming socket protocol=%j&#x27;, protocol);

// No way we can do anything with the socket
if (!protocol || protocol === &#x27;http/1.1&#x27; || protocol === &#x27;http/1.0&#x27;) {
  debug(&#x27;to default handler it goes&#x27;);
  return this.<span class="apidocCodeKeywordSpan">_invokeDefault</span>(socket);
}

socket.setNoDelay(true);

var connection = transport.connection.create(socket, util._extend({
  protocol: /spdy/.test(protocol) ? &#x27;spdy&#x27; : &#x27;http2&#x27;,
  isServer: true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.PlainServer.prototype._onConnection" id="apidoc.element.spdy.PlainServer.prototype._onConnection">
        function <span class="apidocSignatureSpan">spdy.PlainServer.prototype.</span>_onConnection
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _onConnection(socket) {
  var state = this._spdyState;

  var protocol;
  if (state.secure)
    protocol = socket.npnProtocol || socket.alpnProtocol;

  this._handleConnection(socket, protocol);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.PlainServer.prototype._onPlainConnection" id="apidoc.element.spdy.PlainServer.prototype._onPlainConnection">
        function <span class="apidocSignatureSpan">spdy.PlainServer.prototype.</span>_onPlainConnection
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _onPlainConnection(socket) {
  var hose = selectHose.create(socket, {}, hoseFilter);

  var self = this;
  hose.on(&#x27;select&#x27;, function(protocol, socket) {
    self._handleConnection(socket, protocol);
  });

  hose.on(&#x27;error&#x27;, function(err) {
    debug(&#x27;hose error %j&#x27;, err.message);
    socket.destroy();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.PlainServer.prototype._onStream" id="apidoc.element.spdy.PlainServer.prototype._onStream">
        function <span class="apidocSignatureSpan">spdy.PlainServer.prototype.</span>_onStream
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _onStream(stream) {
  var state = this._spdyState;

  var handle = spdy.handle.create(this._spdyState.options, stream);

  var socketOptions = {
    handle: handle,
    allowHalfOpen: true
  };

  var socket;
  if (state.secure)
    socket = new spdy.Socket(stream.connection.socket, socketOptions);
  else
    socket = new net.Socket(socketOptions);

  handle.assignSocket(socket);

  // For v0.8
  socket.readable = true;
  socket.writable = true;

  this._invokeDefault(socket);

  // Add lazy `checkContinue` listener, otherwise `res.writeContinue` will be
  // called before the response object was patched by us.
  if (stream.headers.expect !== undefined &#x26;&#x26;
      /100-continue/i.test(stream.headers.expect) &#x26;&#x26;
      EventEmitter.listenerCount(this, &#x27;checkContinue&#x27;) === 0) {
    this.once(&#x27;checkContinue&#x27;, function(req, res) {
      res.writeContinue();

      this.emit(&#x27;request&#x27;, req, res);
    });
  }

  handle.emitRequest();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  connection.on(&#x27;error&#x27;, function() {
    socket.destroy();
  });

  var self = this;
  connection.on(&#x27;stream&#x27;, function(stream) {
    self.<span class="apidocCodeKeywordSpan">_onStream</span>(stream);
  });
};

// HTTP2 preface
var PREFACE = &#x27;PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n&#x27;;
var PREFACE_BUFFER = new Buffer(PREFACE);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.PlainServer.prototype.emit" id="apidoc.element.spdy.PlainServer.prototype.emit">
        function <span class="apidocSignatureSpan">spdy.PlainServer.prototype.</span>emit
        <span class="apidocSignatureSpan">(event, req, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emit(event, req, res) {
  if (event !== &#x27;request&#x27; &#x26;&#x26; event !== &#x27;checkContinue&#x27;)
    return EventEmitter.prototype.emit.apply(this, arguments);

  if (!(req.socket._handle instanceof spdy.handle)) {
    debug(&#x27;not spdy req/res&#x27;);
    req.isSpdy = false;
    req.spdyVersion = 1;
    res.isSpdy = false;
    res.spdyVersion = 1;
    return EventEmitter.prototype.emit.apply(this, arguments);
  }

  var handle = req.connection._handle;

  req.isSpdy = true;
  req.spdyVersion = handle.getStream().connection.getVersion();
  res.isSpdy = true;
  res.spdyVersion = req.spdyVersion;
  req.spdyStream = handle.getStream();

  debug(&#x27;override req/res&#x27;);
  res.writeHead = spdy.response.writeHead;
  res.end = spdy.response.end;
  res.push = spdy.response.push;
  res.writeContinue = spdy.response.writeContinue;
  res.spdyStream = handle.getStream();

  res._req = req;

  handle.assignRequest(req);
  handle.assignResponse(res);

  return EventEmitter.prototype.emit.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
to the `error` event and re-emit the captured error:

```javascript
var agent = spdy.createAgent({
  host: &#x27;www.google.com&#x27;,
  port: 443
}).once(&#x27;error&#x27;, function (err) {
  this.<span class="apidocCodeKeywordSpan">emit</span>(err);
});
```

## API

API is compatible with `http` and `https` module, but you can use another
function as base class for SPDYServer.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.PlainServer.super_" id="apidoc.module.spdy.PlainServer.super_">module spdy.PlainServer.super_</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.PlainServer.super_.super_" id="apidoc.element.spdy.PlainServer.super_.super_">
        function <span class="apidocSignatureSpan">spdy.PlainServer.</span>super_
        <span class="apidocSignatureSpan">(options, connectionListener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(options, connectionListener) {
  if (!(this instanceof Server))
    return new Server(options, connectionListener);

  EventEmitter.call(this);

  if (typeof options === &#x27;function&#x27;) {
    connectionListener = options;
    options = {};
    this.on(&#x27;connection&#x27;, connectionListener);
  } else if (options == null || typeof options === &#x27;object&#x27;) {
    options = options || {};

    if (typeof connectionListener === &#x27;function&#x27;) {
      this.on(&#x27;connection&#x27;, connectionListener);
    }
  } else {
    throw new TypeError(&#x27;options must be an object&#x27;);
  }

  this._connections = 0;

  Object.defineProperty(this, &#x27;connections&#x27;, {
    get: internalUtil.deprecate(() =&#x3e; {

      if (this._usingSlaves) {
        return null;
      }
      return this._connections;
    }, &#x27;Server.connections property is deprecated. &#x27; +
       &#x27;Use Server.getConnections method instead.&#x27;),
    set: internalUtil.deprecate((val) =&#x3e; {
      return (this._connections = val);
    }, &#x27;Server.connections property is deprecated.&#x27;),
    configurable: true, enumerable: false
  });

  this._handle = null;
  this._usingSlaves = false;
  this._slaves = [];
  this._unref = false;

  this.allowHalfOpen = options.allowHalfOpen || false;
  this.pauseOnConnect = !!options.pauseOnConnect;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.PlainServer.super_.prototype" id="apidoc.module.spdy.PlainServer.super_.prototype">module spdy.PlainServer.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.PlainServer.super_.prototype.setTimeout" id="apidoc.element.spdy.PlainServer.super_.prototype.setTimeout">
        function <span class="apidocSignatureSpan">spdy.PlainServer.super_.prototype.</span>setTimeout
        <span class="apidocSignatureSpan">(msecs, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setTimeout = function (msecs, callback) {
  this.timeout = msecs;
  if (callback)
    this.on(&#x27;timeout&#x27;, callback);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.PlainServer.super_.super_.prototype" id="apidoc.module.spdy.PlainServer.super_.super_.prototype">module spdy.PlainServer.super_.super_.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.spdy.PlainServer.super_.super_.prototype._emitCloseIfDrained" id="apidoc.element.spdy.PlainServer.super_.super_.prototype._emitCloseIfDrained">
        function <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>_emitCloseIfDrained
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_emitCloseIfDrained = function () {
  debug(&#x27;SERVER _emitCloseIfDrained&#x27;);

  if (this._handle || this._connections) {
    debug(&#x27;SERVER handle? %j   connections? %d&#x27;,
          !!this._handle, this._connections);
    return;
  }

  process.nextTick(emitCloseNT, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.PlainServer.super_.super_.prototype._listen2" id="apidoc.element.spdy.PlainServer.super_.super_.prototype._listen2">
        function <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>_listen2
        <span class="apidocSignatureSpan">(address, port, addressType, backlog, fd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_listen2 = function (address, port, addressType, backlog, fd) {
  debug(&#x27;listen2&#x27;, address, port, addressType, backlog, fd);

  // If there is not yet a handle, we need to create one and bind.
  // In the case of a server sent via IPC, we don&#x27;t need to do this.
  if (this._handle) {
    debug(&#x27;_listen2: have a handle already&#x27;);
  } else {
    debug(&#x27;_listen2: create a handle&#x27;);

    var rval = null;

    if (!address &#x26;&#x26; typeof fd !== &#x27;number&#x27;) {
      rval = createServerHandle(&#x27;::&#x27;, port, 6, fd);

      if (typeof rval === &#x27;number&#x27;) {
        rval = null;
        address = &#x27;0.0.0.0&#x27;;
        addressType = 4;
      } else {
        address = &#x27;::&#x27;;
        addressType = 6;
      }
    }

    if (rval === null)
      rval = createServerHandle(address, port, addressType, fd);

    if (typeof rval === &#x27;number&#x27;) {
      var error = exceptionWithHostPort(rval, &#x27;listen&#x27;, address, port);
      process.nextTick(emitErrorNT, this, error);
      return;
    }
    this._handle = rval;
  }

  this._handle.onconnection = onconnection;
  this._handle.owner = this;

  var err = _listen(this._handle, backlog);

  if (err) {
    var ex = exceptionWithHostPort(err, &#x27;listen&#x27;, address, port);
    this._handle.close();
    this._handle = null;
    process.nextTick(emitErrorNT, this, ex);
    return;
  }

  // generate connection key, this should be unique to the connection
  this._connectionKey = addressType + &#x27;:&#x27; + address + &#x27;:&#x27; + port;

  // unref the handle if the server was unref&#x27;ed prior to listening
  if (this._unref)
    this.unref();

  process.nextTick(emitListeningNT, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.PlainServer.super_.super_.prototype._setupSlave" id="apidoc.element.spdy.PlainServer.super_.super_.prototype._setupSlave">
        function <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>_setupSlave
        <span class="apidocSignatureSpan">(socketList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setupSlave = function (socketList) {
  this._usingSlaves = true;
  this._slaves.push(socketList);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.PlainServer.super_.super_.prototype.address" id="apidoc.element.spdy.PlainServer.super_.super_.prototype.address">
        function <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>address
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">address = function () {
  if (this._handle &#x26;&#x26; this._handle.getsockname) {
    var out = {};
    this._handle.getsockname(out);
    // TODO(bnoordhuis) Check err and throw?
    return out;
  } else if (this._pipeName) {
    return this._pipeName;
  } else {
    return null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  key: &#x22;-----BEGIN RSA PRIVATE KEY-----\nMIIEpAIBAAKCAQEA4YyUIzAnCuSz43HXIPfX60XTeXJLYZZXHnyJIXdBkgE2Ou0F\nhWg0wgbicSiyCoRVQHdFcWhIYQRCq2qu3YKetRxD
/MNY9X0h0cPwf3vYP0Bqowhz\neXPc9DoUl0IwbbolYeHlchgm59w9y/UrjO8fEXxhiBpZnllR2N8C0J6p0T9Itn9y\nxN0iWOuZonrvC8upBquniDnW8X5jwTMUEMbCKBQsVoHZm7R+wfX6BfWTUDGFDh1s\norgMqFarP8TRMYqCFUfM/DFS1CeicpvN6i9SixmboIudSRXOHA+FCh0MrW+JxjDt\nBGHq3AZP0y5+f5ETQvtCWBR1xhv3fHGILshiMQIDAQABAoIBAETE5g3siprprGd2\nuE8XAkB748StsooomptzASSxBc8Mi4pf5kUMxrk5/CTgcZh/TLcBJq0zTI44DFPT\njUmAn/88hQY2UZNX+c3JXjSggAiZDWp0EzE+wGm+o7SSu81Y6jjz9U9aSdJ79mOP\ndx3bcq+UKvCiiBydwzTKmkMdfU2M2Wh/LVerXIlO5P4GsEsbenf53iafj0sHOY4W\n8mf1cWHl8/N+5Eh+0GDIIITGOjmGqNKLZOOg66wjzdY9WbCMTJUWIUjRHjCoG6ZA\nJz+vdsZQVN7M4zy8/fKkE4Vx9NEoJcDfZYa/4uo9r274TK7pJD448nTgRCKOJfMR\nCuxZHXkCgYEA5obXLtRiYXhHyXZOs/Yu9/1Iwm6zHiU66/eFRNGHzTssbPSle1kK\n/2LI3+xiRTI8PfztVP6br5/cWLKhu1ZVebCn+wJJbhpHTfAw1k1YXaCjwHh2l1OF\nPBbT4BPjK2ELNzMMF8veLY6S4yY3bQn8xUmbjQtOYuKDvFgoYAsXQo8CgYEA+nju\nhqAXSDW9yoYQBAXoduEaQH2qNfwRzY6V8rkwISI1seLPlcsd0Kc/VDOSwRdCWOk2\njn5LKPql6FfZ+9MVtPjlVLFjLcEzXttH+PkFtoA9Ffj9cxe3owNjR/tbfoHa19pV\n6+vBZJF48AlkErmVzTNlFJGWh7GtY6LgaOwdbz8CgYEAwhFaLe5WNEASDyQt9YqW\n1+a+zhBrckFdbTEfXGQYs0nRiJgch87aV01OVlSmFiLIXFcFZbxCTIOD+JfJV/DC\nXIO/pqyyLKKqzI4cTw0mCwwlTu8axyJk08VT8RxM7kPwMTQkRhQ2opuYROnzVzRF\nO8FP1lliUBTpWjHNK62qkzkCgYBZg+rLVl+7wOkpfiwvI+VmxyBYuBCi5ol+S10v\nuBuJW+6QupyxzjvDnGI3t47VT3i4yfBjkKNP6/RrSypuo4v4d5OOZy8o5Ql09y2L\nv4PZK4+pUKlT/r/0lHtg+GZEmigaSL+4ZzNgu9TbBKAtSQJOqfWQGlAQAuIS390P\n4oLKhQKBgQDiuimWRSpW3vBepzeH3SuJqm5yx/ms5RUdFH1tc/0vMZR9x/c4Ai2r\ns+1E3KacY/5z9D6t5PWaDj5Sbw8dz0zI7nvnIvufznaaGGqWlrPACQndQLnPrPSr\niFltJhhNQAMlAVOeOz75IQGuC4swdXxbdWXXPrmN9VKGPjClqU+/+w==\n-----END RSA PRIVATE KEY-----&#x22;,
  cert: &#x22;-----BEGIN CERTIFICATE-----\nMIICvDCCAaagAwIBAgIDAQABMAsGCSqGSIb3DQEBDTAVMRMwEQYDVQQDFgpsb2Nh\nbC5ob3N0MB4XDTE2MDkxNzE5MDEyOVoXDTI2MDkxNjE5MDEyOVowFTETMBEGA1UE\nAxYKbG9jYWwuaG9zdDCCASAwCwYJKoZIhvcNAQEBA4IBDwAwggEKAoIBAQDhjJQj\nMCcK5LPjcdcg99frRdN5ckthllcefIkhd0GSATY67QWFaDTCBuJxKLIKhFVAd0Vx\naEhhBEKraq7dgp61HEP8w1j1fSHRw/B/e9g/QGqjCHN5c9z0OhSXQjBtuiVh4eVy\nGCbn3D3L9SuM7x8RfGGIGlmeWVHY3wLQnqnRP0i2f3LE3SJY65mieu8Ly6kGq6eI\nOdbxfmPBMxQQxsIoFCxWgdmbtH7B9foF9ZNQMYUOHWyiuAyoVqs/xNExioIVR8z8\nMVLUJ6Jym83qL1KLGZugi51JFc4cD4UKHQytb4nGMO0EYercBk/TLn5/kRNC+0JY\nFHXGG/d8cYguyGIxAgMBAAGjGzAZMBcGA1UdEQQQMA6CDCoubG9jYWwuaG9zdDAL\nBgkqhkiG9w0BAQ0DggEBAHX840Wl7APZi20i+H+eSL70/tGfld487CBnxfzvECWh\nC+mOfMH9LHSkRhkk+kyosClKO07moUev39EppR7rXhh/fDJLUAbH8Hpb8gJBu0R6\nceQQmqoHCFApqdDF0quvKq5RVatQHfTTuSNd2y/kPD6otnEfxk91rg10dpwd0jii\nv7JBV8cC+z6bDBKn46P8Hpy0k2AY8LgIpUdnmLecxcPAGh0TpGe/2FuYtvPey7vR\nKl4sqjtreZ5kbrqoKRGTU/X2bXHjhF22ZmWO/O0lv1rLrnXCnxQrSTwvXHfNsxkZ\nVqvOQufB7zDfcVrXAeQr7RpyP9qSF9aQwDQj8uio/dI=\n-----END CERTIFICATE-----&#x22;
};

const server = spdy.createServer(options, (req, res) =&#x3e; {
  res.end(&#x27;hello&#x27;);
}).listen(443, () =&#x3e; {
  console.log(&#x27;Listening&#x27;, server.<span class="apidocCodeKeywordSpan">address</span>());
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.PlainServer.super_.super_.prototype.close" id="apidoc.element.spdy.PlainServer.super_.super_.prototype.close">
        function <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {
  function onSlaveClose() {
    if (--left !== 0) return;

    self._connections = 0;
    self._emitCloseIfDrained();
  }

  if (typeof cb === &#x27;function&#x27;) {
    if (!this._handle) {
      this.once(&#x27;close&#x27;, function() {
        cb(new Error(&#x27;Not running&#x27;));
      });
    } else {
      this.once(&#x27;close&#x27;, cb);
    }
  }

  if (this._handle) {
    this._handle.close();
    this._handle = null;
  }

  if (this._usingSlaves) {
    var self = this;
    var left = this._slaves.length;

    // Increment connections to be sure that, even if all sockets will be closed
    // during polling of slaves, `close` event will be emitted only once.
    this._connections++;

    // Poll slaves
    this._slaves.forEach(function(slave) {
      slave.close(onSlaveClose);
    });
  } else {
    this._emitCloseIfDrained();
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  agent: agent
}, function(response) {
  console.log(&#x27;yikes&#x27;);
  // Here it goes like with any other node.js HTTP request
  // ...
  // And once we&#x27;re done - we may close TCP connection to server
  // NOTE: All non-closed requests will die!
  agent.<span class="apidocCodeKeywordSpan">close</span>();
}).end();
```

Please note that if you use a custom agent, by default all connection-level
errors will result in an uncaught exception. To handle these errors subscribe
to the `error` event and re-emit the captured error:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.PlainServer.super_.super_.prototype.getConnections" id="apidoc.element.spdy.PlainServer.super_.super_.prototype.getConnections">
        function <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>getConnections
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConnections = function (cb) {
  function end(err, connections) {
    process.nextTick(cb, err, connections);
  }

  if (!this._usingSlaves) {
    return end(null, this._connections);
  }

  // Poll slaves
  var left = this._slaves.length;
  var total = this._connections;

  function oncount(err, count) {
    if (err) {
      left = -1;
      return end(err);
    }

    total += count;
    if (--left === 0) return end(null, total);
  }

  this._slaves.forEach(function(slave) {
    slave.getConnections(oncount);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.PlainServer.super_.super_.prototype.listen" id="apidoc.element.spdy.PlainServer.super_.super_.prototype.listen">
        function <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function () {
  var self = this;

  var lastArg = arguments[arguments.length - 1];
  if (typeof lastArg === &#x27;function&#x27;) {
    self.once(&#x27;listening&#x27;, lastArg);
  }

  var port = toNumber(arguments[0]);

  // The third optional argument is the backlog size.
  // When the ip is omitted it can be the second argument.
  var backlog = toNumber(arguments[1]) || toNumber(arguments[2]);

  if (arguments.length === 0 || typeof arguments[0] === &#x27;function&#x27;) {
    // Bind to a random port.
    listen(self, null, 0, null, backlog);
  } else if (arguments[0] !== null &#x26;&#x26; typeof arguments[0] === &#x27;object&#x27;) {
    var h = arguments[0];
    h = h._handle || h.handle || h;

    if (h instanceof TCP) {
      self._handle = h;
      listen(self, null, -1, -1, backlog);
    } else if (typeof h.fd === &#x27;number&#x27; &#x26;&#x26; h.fd &#x3e;= 0) {
      listen(self, null, null, null, backlog, h.fd);
    } else {
      // The first argument is a configuration object
      if (h.backlog)
        backlog = h.backlog;

      if (typeof h.port === &#x27;number&#x27; || typeof h.port === &#x27;string&#x27; ||
          (typeof h.port === &#x27;undefined&#x27; &#x26;&#x26; &#x27;port&#x27; in h)) {
        // Undefined is interpreted as zero (random port) for consistency
        // with net.connect().
        assertPort(h.port);
        if (h.host)
          listenAfterLookup(h.port | 0, h.host, backlog, h.exclusive);
        else
          listen(self, null, h.port | 0, 4, backlog, undefined, h.exclusive);
      } else if (h.path &#x26;&#x26; isPipeName(h.path)) {
        const pipeName = self._pipeName = h.path;
        listen(self, pipeName, -1, -1, backlog, undefined, h.exclusive);
      } else {
        throw new Error(&#x27;Invalid listen argument: &#x27; + h);
      }
    }
  } else if (isPipeName(arguments[0])) {
    // UNIX socket or Windows pipe.
    const pipeName = self._pipeName = arguments[0];
    listen(self, pipeName, -1, -1, backlog);

  } else if (arguments[1] === undefined ||
             typeof arguments[1] === &#x27;function&#x27; ||
             typeof arguments[1] === &#x27;number&#x27;) {
    // The first argument is the port, no IP given.
    assertPort(port);
    listen(self, null, port, 4, backlog);

  } else {
    // The first argument is the port, the second an IP.
    assertPort(port);
    listenAfterLookup(port, arguments[1], backlog);
  }

  function listenAfterLookup(port, address, backlog, exclusive) {
    require(&#x27;dns&#x27;).lookup(address, function(err, ip, addressType) {
      if (err) {
        self.emit(&#x27;error&#x27;, err);
      } else {
        addressType = ip ? addressType : 4;
        listen(self, ip, port, addressType, backlog, undefined, exclusive);
      }
    });
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

var server = spdy.createServer(options, function(req, res) {
  res.writeHead(200);
  res.end(&#x27;hello world!&#x27;);
});

server.<span class="apidocCodeKeywordSpan">listen</span>(3000);
```

Client:
```javascript
var spdy = require(&#x27;spdy&#x27;);
var http = require(&#x27;http&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.PlainServer.super_.super_.prototype.listenFD" id="apidoc.element.spdy.PlainServer.super_.super_.prototype.listenFD">
        function <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>listenFD
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecated() {
  warned = exports.printDeprecationMessage(msg, warned, deprecated);
  if (new.target) {
    return Reflect.construct(fn, arguments, new.target);
  }
  return fn.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.PlainServer.super_.super_.prototype.ref" id="apidoc.element.spdy.PlainServer.super_.super_.prototype.ref">
        function <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>ref
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ref = function () {
  this._unref = false;

  if (this._handle)
    this._handle.ref();

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.PlainServer.super_.super_.prototype.unref" id="apidoc.element.spdy.PlainServer.super_.super_.prototype.unref">
        function <span class="apidocSignatureSpan">spdy.PlainServer.super_.super_.prototype.</span>unref
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unref = function () {
  this._unref = true;

  if (this._handle)
    this._handle.unref();

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.Server" id="apidoc.module.spdy.Server">module spdy.Server</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.Server.Server" id="apidoc.element.spdy.Server.Server">
        function <span class="apidocSignatureSpan">spdy.</span>Server
        <span class="apidocSignatureSpan">(options, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(options, handler) {
  this._init(base, options, handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Server.create" id="apidoc.element.spdy.Server.create">
        function <span class="apidocSignatureSpan">spdy.Server.</span>create
        <span class="apidocSignatureSpan">(options, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(options, handler) {
  return new Server(options, handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

server.listen(fixtures.port, function() {
  var socket = (plain ? net : tls).connect({
    rejectUnauthorized: false,
    port: fixtures.port,
    NPNProtocols: [ npn ]
  }, function() {
    client = transport.connection.<span class="apidocCodeKeywordSpan">create</span>(socket, {
      protocol: protocol,
      isServer: false
    });
    client.start(version);
    done();
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Server.super_" id="apidoc.element.spdy.Server.super_">
        function <span class="apidocSignatureSpan">spdy.Server.</span>super_
        <span class="apidocSignatureSpan">(opts, requestListener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(opts, requestListener) {
  if (!(this instanceof Server)) return new Server(opts, requestListener);

  if (process.features.tls_npn &#x26;&#x26; !opts.NPNProtocols) {
    opts.NPNProtocols = [&#x27;http/1.1&#x27;, &#x27;http/1.0&#x27;];
  }

  if (process.features.tls_alpn &#x26;&#x26; !opts.ALPNProtocols) {
    // http/1.0 is not defined as Protocol IDs in IANA
    // http://www.iana.org/assignments/tls-extensiontype-values
    //       /tls-extensiontype-values.xhtml#alpn-protocol-ids
    opts.ALPNProtocols = [&#x27;http/1.1&#x27;];
  }

  tls.Server.call(this, opts, http._connectionListener);

  this.httpAllowHalfOpen = false;

  if (requestListener) {
    this.addListener(&#x27;request&#x27;, requestListener);
  }

  this.addListener(&#x27;tlsClientError&#x27;, function(err, conn) {
    if (!this.emit(&#x27;clientError&#x27;, err, conn))
      conn.destroy(err);
  });

  this.timeout = 2 * 60 * 1000;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.Server.prototype" id="apidoc.module.spdy.Server.prototype">module spdy.Server.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.Server.prototype._handleConnection" id="apidoc.element.spdy.Server.prototype._handleConnection">
        function <span class="apidocSignatureSpan">spdy.Server.prototype.</span>_handleConnection
        <span class="apidocSignatureSpan">(socket, protocol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _handleConnection(socket, protocol) {
  var state = this._spdyState;

  if (!protocol)
    protocol = state.options.protocol;

  debug(&#x27;incoming socket protocol=%j&#x27;, protocol);

  // No way we can do anything with the socket
  if (!protocol || protocol === &#x27;http/1.1&#x27; || protocol === &#x27;http/1.0&#x27;) {
    debug(&#x27;to default handler it goes&#x27;);
    return this._invokeDefault(socket);
  }

  socket.setNoDelay(true);

  var connection = transport.connection.create(socket, util._extend({
    protocol: /spdy/.test(protocol) ? &#x27;spdy&#x27; : &#x27;http2&#x27;,
    isServer: true
  }, state.options.connection || {}));

  // Set version when we are certain
  if (protocol === &#x27;http2&#x27;)
    connection.start(4);
  else if (protocol === &#x27;spdy/3.1&#x27;)
    connection.start(3.1);
  else if (protocol === &#x27;spdy/3&#x27;)
    connection.start(3);
  else if (protocol === &#x27;spdy/2&#x27;)
    connection.start(2);

  connection.on(&#x27;error&#x27;, function() {
    socket.destroy();
  });

  var self = this;
  connection.on(&#x27;stream&#x27;, function(stream) {
    self._onStream(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
proto._onConnection = function _onConnection(socket) {
var state = this._spdyState;

var protocol;
if (state.secure)
  protocol = socket.npnProtocol || socket.alpnProtocol;

this.<span class="apidocCodeKeywordSpan">_handleConnection</span>(socket, protocol);
};

proto._handleConnection = function _handleConnection(socket, protocol) {
var state = this._spdyState;

if (!protocol)
  protocol = state.options.protocol;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Server.prototype._init" id="apidoc.element.spdy.Server.prototype._init">
        function <span class="apidocSignatureSpan">spdy.Server.prototype.</span>_init
        <span class="apidocSignatureSpan">(base, options, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _init(base, options, handler) {
  var state = {};
  this._spdyState = state;

  state.options = options.spdy || {};

  var protocols = state.options.protocols || [
    &#x27;h2&#x27;,
    &#x27;spdy/3.1&#x27;, &#x27;spdy/3&#x27;, &#x27;spdy/2&#x27;,
    &#x27;http/1.1&#x27;, &#x27;http/1.0&#x27;
  ];

  var actualOptions = util._extend({
    NPNProtocols: protocols,

    // Future-proof
    ALPNProtocols: protocols
  }, options);

  state.secure = this instanceof tls.Server;

  if (state.secure)
    base.call(this, actualOptions);
  else
    base.call(this);

  // Support HEADERS+FIN
  this.httpAllowHalfOpen = true;

  var event = state.secure ? &#x27;secureConnection&#x27; : &#x27;connection&#x27;;

  state.listeners = this.listeners(event).slice();
  assert(state.listeners.length &#x3e; 0, &#x27;Server does not have default listeners&#x27;);
  this.removeAllListeners(event);

  if (state.options.plain)
    this.on(event, this._onPlainConnection);
  else
    this.on(event, this._onConnection);

  if (handler)
    this.on(&#x27;request&#x27;, handler);

  debug(&#x27;server init secure=%d&#x27;, state.secure);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         /^v0\.12\./.test(process.version) ? &#x27;normal&#x27; :
         &#x27;modern&#x27;;

var proto = {};

function instantiate(base) {
function Agent(options) {
  this.<span class="apidocCodeKeywordSpan">_init</span>(base, options);
}
util.inherits(Agent, base);

Agent.create = function create(options) {
  return new Agent(options);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Server.prototype._invokeDefault" id="apidoc.element.spdy.Server.prototype._invokeDefault">
        function <span class="apidocSignatureSpan">spdy.Server.prototype.</span>_invokeDefault
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _invokeDefault(socket) {
  var state = this._spdyState;

  for (var i = 0; i &#x3c; state.listeners.length; i++)
    state.listeners[i].call(this, socket);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  protocol = state.options.protocol;

debug(&#x27;incoming socket protocol=%j&#x27;, protocol);

// No way we can do anything with the socket
if (!protocol || protocol === &#x27;http/1.1&#x27; || protocol === &#x27;http/1.0&#x27;) {
  debug(&#x27;to default handler it goes&#x27;);
  return this.<span class="apidocCodeKeywordSpan">_invokeDefault</span>(socket);
}

socket.setNoDelay(true);

var connection = transport.connection.create(socket, util._extend({
  protocol: /spdy/.test(protocol) ? &#x27;spdy&#x27; : &#x27;http2&#x27;,
  isServer: true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Server.prototype._onConnection" id="apidoc.element.spdy.Server.prototype._onConnection">
        function <span class="apidocSignatureSpan">spdy.Server.prototype.</span>_onConnection
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _onConnection(socket) {
  var state = this._spdyState;

  var protocol;
  if (state.secure)
    protocol = socket.npnProtocol || socket.alpnProtocol;

  this._handleConnection(socket, protocol);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Server.prototype._onPlainConnection" id="apidoc.element.spdy.Server.prototype._onPlainConnection">
        function <span class="apidocSignatureSpan">spdy.Server.prototype.</span>_onPlainConnection
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _onPlainConnection(socket) {
  var hose = selectHose.create(socket, {}, hoseFilter);

  var self = this;
  hose.on(&#x27;select&#x27;, function(protocol, socket) {
    self._handleConnection(socket, protocol);
  });

  hose.on(&#x27;error&#x27;, function(err) {
    debug(&#x27;hose error %j&#x27;, err.message);
    socket.destroy();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Server.prototype._onStream" id="apidoc.element.spdy.Server.prototype._onStream">
        function <span class="apidocSignatureSpan">spdy.Server.prototype.</span>_onStream
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _onStream(stream) {
  var state = this._spdyState;

  var handle = spdy.handle.create(this._spdyState.options, stream);

  var socketOptions = {
    handle: handle,
    allowHalfOpen: true
  };

  var socket;
  if (state.secure)
    socket = new spdy.Socket(stream.connection.socket, socketOptions);
  else
    socket = new net.Socket(socketOptions);

  handle.assignSocket(socket);

  // For v0.8
  socket.readable = true;
  socket.writable = true;

  this._invokeDefault(socket);

  // Add lazy `checkContinue` listener, otherwise `res.writeContinue` will be
  // called before the response object was patched by us.
  if (stream.headers.expect !== undefined &#x26;&#x26;
      /100-continue/i.test(stream.headers.expect) &#x26;&#x26;
      EventEmitter.listenerCount(this, &#x27;checkContinue&#x27;) === 0) {
    this.once(&#x27;checkContinue&#x27;, function(req, res) {
      res.writeContinue();

      this.emit(&#x27;request&#x27;, req, res);
    });
  }

  handle.emitRequest();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  connection.on(&#x27;error&#x27;, function() {
    socket.destroy();
  });

  var self = this;
  connection.on(&#x27;stream&#x27;, function(stream) {
    self.<span class="apidocCodeKeywordSpan">_onStream</span>(stream);
  });
};

// HTTP2 preface
var PREFACE = &#x27;PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n&#x27;;
var PREFACE_BUFFER = new Buffer(PREFACE);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Server.prototype.emit" id="apidoc.element.spdy.Server.prototype.emit">
        function <span class="apidocSignatureSpan">spdy.Server.prototype.</span>emit
        <span class="apidocSignatureSpan">(event, req, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emit(event, req, res) {
  if (event !== &#x27;request&#x27; &#x26;&#x26; event !== &#x27;checkContinue&#x27;)
    return EventEmitter.prototype.emit.apply(this, arguments);

  if (!(req.socket._handle instanceof spdy.handle)) {
    debug(&#x27;not spdy req/res&#x27;);
    req.isSpdy = false;
    req.spdyVersion = 1;
    res.isSpdy = false;
    res.spdyVersion = 1;
    return EventEmitter.prototype.emit.apply(this, arguments);
  }

  var handle = req.connection._handle;

  req.isSpdy = true;
  req.spdyVersion = handle.getStream().connection.getVersion();
  res.isSpdy = true;
  res.spdyVersion = req.spdyVersion;
  req.spdyStream = handle.getStream();

  debug(&#x27;override req/res&#x27;);
  res.writeHead = spdy.response.writeHead;
  res.end = spdy.response.end;
  res.push = spdy.response.push;
  res.writeContinue = spdy.response.writeContinue;
  res.spdyStream = handle.getStream();

  res._req = req;

  handle.assignRequest(req);
  handle.assignResponse(res);

  return EventEmitter.prototype.emit.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
to the `error` event and re-emit the captured error:

```javascript
var agent = spdy.createAgent({
  host: &#x27;www.google.com&#x27;,
  port: 443
}).once(&#x27;error&#x27;, function (err) {
  this.<span class="apidocCodeKeywordSpan">emit</span>(err);
});
```

## API

API is compatible with `http` and `https` module, but you can use another
function as base class for SPDYServer.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.Server.super_" id="apidoc.module.spdy.Server.super_">module spdy.Server.super_</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.Server.super_.super_" id="apidoc.element.spdy.Server.super_.super_">
        function <span class="apidocSignatureSpan">spdy.Server.</span>super_
        <span class="apidocSignatureSpan">(options, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(options, listener) {
  if (!(this instanceof Server))
    return new Server(options, listener);

  if (typeof options === &#x27;function&#x27;) {
    listener = options;
    options = {};
  } else if (options == null || typeof options === &#x27;object&#x27;) {
    options = options || {};
  } else {
    throw new TypeError(&#x27;options must be an object&#x27;);
  }


  this._contexts = [];

  var self = this;

  // Handle option defaults:
  this.setOptions(options);

  var sharedCreds = tls.createSecureContext({
    pfx: self.pfx,
    key: self.key,
    passphrase: self.passphrase,
    cert: self.cert,
    ca: self.ca,
    ciphers: self.ciphers,
    ecdhCurve: self.ecdhCurve,
    dhparam: self.dhparam,
    secureProtocol: self.secureProtocol,
    secureOptions: self.secureOptions,
    honorCipherOrder: self.honorCipherOrder,
    crl: self.crl,
    sessionIdContext: self.sessionIdContext
  });
  this._sharedCreds = sharedCreds;

  var timeout = options.handshakeTimeout || (120 * 1000);

  if (typeof timeout !== &#x27;number&#x27;) {
    throw new TypeError(&#x27;handshakeTimeout must be a number&#x27;);
  }

  if (self.sessionTimeout) {
    sharedCreds.context.setSessionTimeout(self.sessionTimeout);
  }

  if (self.ticketKeys) {
    sharedCreds.context.setTicketKeys(self.ticketKeys);
  }

  // constructor call
  net.Server.call(this, function(raw_socket) {
    var socket = new TLSSocket(raw_socket, {
      secureContext: sharedCreds,
      isServer: true,
      server: self,
      requestCert: self.requestCert,
      rejectUnauthorized: self.rejectUnauthorized,
      handshakeTimeout: timeout,
      NPNProtocols: self.NPNProtocols,
      ALPNProtocols: self.ALPNProtocols,
      SNICallback: options.SNICallback || SNICallback
    });

    socket.on(&#x27;secure&#x27;, function() {
      if (socket._requestCert) {
        var verifyError = socket._handle.verifyError();
        if (verifyError) {
          socket.authorizationError = verifyError.code;

          if (socket._rejectUnauthorized)
            socket.destroy();
        } else {
          socket.authorized = true;
        }
      }

      if (!socket.destroyed &#x26;&#x26; socket._releaseControl())
        self.emit(&#x27;secureConnection&#x27;, socket);
    });

    var errorEmitted = false;
    socket.on(&#x27;close&#x27;, function(err) {
      // Closed because of error - no need to emit it twice
      if (err)
        return;

      // Emit ECONNRESET
      if (!socket._controlReleased &#x26;&#x26; !errorEmitted) {
        errorEmitted = true;
        var connReset = new Error(&#x27;socket hang up&#x27;);
        connReset.code = &#x27;ECONNRESET&#x27;;
        self.emit(&#x27;tlsClientError&#x27;, connReset, socket);
      }
    });

    socket.on(&#x27;_tlsError&#x27;, function(err) {
      if (!socket._controlReleased &#x26;&#x26; !errorEmitted) {
        errorEmitted = true;
        self.emit(&#x27;tlsClientError&#x27;, err, socket);
      }
    });
  });

  if (listener) {
    this.on(&#x27;secureConnection&#x27;, listener);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.Server.super_.prototype" id="apidoc.module.spdy.Server.super_.prototype">module spdy.Server.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.Server.super_.prototype.setTimeout" id="apidoc.element.spdy.Server.super_.prototype.setTimeout">
        function <span class="apidocSignatureSpan">spdy.Server.super_.prototype.</span>setTimeout
        <span class="apidocSignatureSpan">(msecs, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setTimeout = function (msecs, callback) {
  this.timeout = msecs;
  if (callback)
    this.on(&#x27;timeout&#x27;, callback);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.Server.super_.super_.prototype" id="apidoc.module.spdy.Server.super_.super_.prototype">module spdy.Server.super_.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.Server.super_.super_.prototype._getServerData" id="apidoc.element.spdy.Server.super_.super_.prototype._getServerData">
        function <span class="apidocSignatureSpan">spdy.Server.super_.super_.prototype.</span>_getServerData
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getServerData = function () {
  return {
    ticketKeys: this.getTicketKeys().toString(&#x27;hex&#x27;)
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Server.super_.super_.prototype._setServerData" id="apidoc.element.spdy.Server.super_.super_.prototype._setServerData">
        function <span class="apidocSignatureSpan">spdy.Server.super_.super_.prototype.</span>_setServerData
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setServerData = function (data) {
  this.setTicketKeys(Buffer.from(data.ticketKeys, &#x27;hex&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Server.super_.super_.prototype.addContext" id="apidoc.element.spdy.Server.super_.super_.prototype.addContext">
        function <span class="apidocSignatureSpan">spdy.Server.super_.super_.prototype.</span>addContext
        <span class="apidocSignatureSpan">(servername, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addContext = function (servername, context) {
  if (!servername) {
    throw new Error(&#x27;&#x22;servername&#x22; is required parameter for Server.addContext&#x27;);
  }

  var re = new RegExp(&#x27;^&#x27; +
                      servername.replace(/([.^$+?\-\\[\]{}])/g, &#x27;\\$1&#x27;)
                                .replace(/\*/g, &#x27;[^.]*&#x27;) +
                      &#x27;$&#x27;);
  this._contexts.push([re, tls.createSecureContext(context).context]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Server.super_.super_.prototype.getTicketKeys" id="apidoc.element.spdy.Server.super_.super_.prototype.getTicketKeys">
        function <span class="apidocSignatureSpan">spdy.Server.super_.super_.prototype.</span>getTicketKeys
        <span class="apidocSignatureSpan">(keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTicketKeys(keys) {
  return this._sharedCreds.context.getTicketKeys(keys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Server.super_.super_.prototype.setOptions" id="apidoc.element.spdy.Server.super_.super_.prototype.setOptions">
        function <span class="apidocSignatureSpan">spdy.Server.super_.super_.prototype.</span>setOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setOptions = function (options) {
  if (typeof options.requestCert === &#x27;boolean&#x27;) {
    this.requestCert = options.requestCert;
  } else {
    this.requestCert = false;
  }

  if (typeof options.rejectUnauthorized === &#x27;boolean&#x27;) {
    this.rejectUnauthorized = options.rejectUnauthorized;
  } else {
    this.rejectUnauthorized = false;
  }

  if (options.pfx) this.pfx = options.pfx;
  if (options.key) this.key = options.key;
  if (options.passphrase) this.passphrase = options.passphrase;
  if (options.cert) this.cert = options.cert;
  if (options.ca) this.ca = options.ca;
  if (options.secureProtocol) this.secureProtocol = options.secureProtocol;
  if (options.crl) this.crl = options.crl;
  if (options.ciphers) this.ciphers = options.ciphers;
  if (options.ecdhCurve !== undefined)
    this.ecdhCurve = options.ecdhCurve;
  if (options.dhparam) this.dhparam = options.dhparam;
  if (options.sessionTimeout) this.sessionTimeout = options.sessionTimeout;
  if (options.ticketKeys) this.ticketKeys = options.ticketKeys;
  var secureOptions = options.secureOptions || 0;
  if (options.honorCipherOrder !== undefined)
    this.honorCipherOrder = !!options.honorCipherOrder;
  else
    this.honorCipherOrder = true;
  if (secureOptions) this.secureOptions = secureOptions;
  if (options.NPNProtocols) tls.convertNPNProtocols(options.NPNProtocols, this);
  if (options.ALPNProtocols)
    tls.convertALPNProtocols(options.ALPNProtocols, this);
  if (options.sessionIdContext) {
    this.sessionIdContext = options.sessionIdContext;
  } else {
    this.sessionIdContext = crypto.createHash(&#x27;sha1&#x27;)
                                  .update(process.argv.join(&#x27; &#x27;))
                                  .digest(&#x27;hex&#x27;)
                                  .slice(0, 32);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Server.super_.super_.prototype.setTicketKeys" id="apidoc.element.spdy.Server.super_.super_.prototype.setTicketKeys">
        function <span class="apidocSignatureSpan">spdy.Server.super_.super_.prototype.</span>setTicketKeys
        <span class="apidocSignatureSpan">(keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setTicketKeys(keys) {
  this._sharedCreds.context.setTicketKeys(keys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.Socket" id="apidoc.module.spdy.Socket">module spdy.Socket</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.Socket.Socket" id="apidoc.element.spdy.Socket.Socket">
        function <span class="apidocSignatureSpan">spdy.</span>Socket
        <span class="apidocSignatureSpan">(parent, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Socket(parent, options) {
  net.Socket.call(this, options);

  var state = {};

  this._spdyState = state;

  state.parent = parent;

  this.servername = parent.servername;
  this.npnProtocol = parent.npnProtocol;
  this.alpnProtocol = parent.alpnProtocol;
  this.authorized = parent.authorized;
  this.authorizationError = parent.authorizationError;
  this.encrypted = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var socketOptions = {
  handle: handle,
  allowHalfOpen: true
};

var socket;
if (state.secure)
  socket = new spdy.<span class="apidocCodeKeywordSpan">Socket</span>(state.socket, socketOptions);
else
  socket = new net.Socket(socketOptions);

handle.assignSocket(socket);
handle.assignClientRequest(req);

// Create stream only once `req.end()` is called
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_" id="apidoc.element.spdy.Socket.super_">
        function <span class="apidocSignatureSpan">spdy.Socket.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Socket(options) {
  if (!(this instanceof Socket)) return new Socket(options);

  this.connecting = false;
  this._hadError = false;
  this._handle = null;
  this._parent = null;
  this._host = null;

  if (typeof options === &#x27;number&#x27;)
    options = { fd: options }; // Legacy interface.
  else if (options === undefined)
    options = {};

  stream.Duplex.call(this, options);

  if (options.handle) {
    this._handle = options.handle; // private
  } else if (options.fd !== undefined) {
    this._handle = createHandle(options.fd);
    this._handle.open(options.fd);
    // options.fd can be string (since it user-defined),
    // so changing this to === would be semver-major
    // See: https://github.com/nodejs/node/pull/11513
    if ((options.fd == 1 || options.fd == 2) &#x26;&#x26;
        (this._handle instanceof Pipe) &#x26;&#x26;
        process.platform === &#x27;win32&#x27;) {
      // Make stdout and stderr blocking on Windows
      var err = this._handle.setBlocking(true);
      if (err)
        throw errnoException(err, &#x27;setBlocking&#x27;);
    }
    this.readable = options.readable !== false;
    this.writable = options.writable !== false;
  } else {
    // these will be set once there is a connection
    this.readable = this.writable = false;
  }

  // shut down the socket when we&#x27;re finished with it.
  this.on(&#x27;finish&#x27;, onSocketFinish);
  this.on(&#x27;_socketEnd&#x27;, onSocketEnd);

  initSocketHandle(this);

  this._pendingData = null;
  this._pendingEncoding = &#x27;&#x27;;

  // handle strings directly
  this._writableState.decodeStrings = false;

  // default to *not* allowing half open sockets
  this.allowHalfOpen = options &#x26;&#x26; options.allowHalfOpen || false;

  // if we have a handle, then start the flow of data into the
  // buffer.  if not, then this will happen when we connect
  if (this._handle &#x26;&#x26; options.readable !== false) {
    if (options.pauseOnCreate) {
      // stop the handle from reading and pause the stream
      this._handle.reading = false;
      this._handle.readStop();
      this._readableState.flowing = false;
    } else {
      this.read(0);
    }
  }

  // Reserve properties
  this.server = null;
  this._server = null;

  // Used after `.destroy()`
  this[BYTES_READ] = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.Socket.prototype" id="apidoc.module.spdy.Socket.prototype">module spdy.Socket.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.Socket.prototype.getCipher" id="apidoc.element.spdy.Socket.prototype.getCipher">
        function <span class="apidocSignatureSpan">spdy.Socket.prototype.</span>getCipher
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function methodWrap() {
  var parent = this._spdyState.parent;
  return parent[method].apply(parent, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.prototype.getEphemeralKeyInfo" id="apidoc.element.spdy.Socket.prototype.getEphemeralKeyInfo">
        function <span class="apidocSignatureSpan">spdy.Socket.prototype.</span>getEphemeralKeyInfo
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function methodWrap() {
  var parent = this._spdyState.parent;
  return parent[method].apply(parent, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.prototype.getPeerCertificate" id="apidoc.element.spdy.Socket.prototype.getPeerCertificate">
        function <span class="apidocSignatureSpan">spdy.Socket.prototype.</span>getPeerCertificate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function methodWrap() {
  var parent = this._spdyState.parent;
  return parent[method].apply(parent, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

      server.on(&#x27;request&#x27;, function(req, res) {
assert.equal(req.isSpdy, res.isSpdy);
assert.equal(req.spdyVersion, res.spdyVersion);
assert(req.isSpdy);
if (!plain) {
  assert(req.socket.encrypted);
  assert(req.socket.<span class="apidocCodeKeywordSpan">getPeerCertificate</span>());
}

// Auto-detection
if (version === 3.1)
  assert(req.spdyVersion &#x3e;= 3 &#x26;&#x26; req.spdyVersion &#x3c;= 3.1);
else
  assert.equal(req.spdyVersion, version);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.prototype.getSession" id="apidoc.element.spdy.Socket.prototype.getSession">
        function <span class="apidocSignatureSpan">spdy.Socket.prototype.</span>getSession
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function methodWrap() {
  var parent = this._spdyState.parent;
  return parent[method].apply(parent, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.prototype.getTLSTicket" id="apidoc.element.spdy.Socket.prototype.getTLSTicket">
        function <span class="apidocSignatureSpan">spdy.Socket.prototype.</span>getTLSTicket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function methodWrap() {
  var parent = this._spdyState.parent;
  return parent[method].apply(parent, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.prototype.isSessionReused" id="apidoc.element.spdy.Socket.prototype.isSessionReused">
        function <span class="apidocSignatureSpan">spdy.Socket.prototype.</span>isSessionReused
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function methodWrap() {
  var parent = this._spdyState.parent;
  return parent[method].apply(parent, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.prototype.renegotiate" id="apidoc.element.spdy.Socket.prototype.renegotiate">
        function <span class="apidocSignatureSpan">spdy.Socket.prototype.</span>renegotiate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function methodWrap() {
  var parent = this._spdyState.parent;
  return parent[method].apply(parent, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.prototype.setMaxSendFragment" id="apidoc.element.spdy.Socket.prototype.setMaxSendFragment">
        function <span class="apidocSignatureSpan">spdy.Socket.prototype.</span>setMaxSendFragment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function methodWrap() {
  var parent = this._spdyState.parent;
  return parent[method].apply(parent, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.prototype.setServername" id="apidoc.element.spdy.Socket.prototype.setServername">
        function <span class="apidocSignatureSpan">spdy.Socket.prototype.</span>setServername
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function methodWrap() {
  var parent = this._spdyState.parent;
  return parent[method].apply(parent, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.prototype.setSession" id="apidoc.element.spdy.Socket.prototype.setSession">
        function <span class="apidocSignatureSpan">spdy.Socket.prototype.</span>setSession
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function methodWrap() {
  var parent = this._spdyState.parent;
  return parent[method].apply(parent, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.Socket.super_" id="apidoc.module.spdy.Socket.super_">module spdy.Socket.super_</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.super_" id="apidoc.element.spdy.Socket.super_.super_">
        function <span class="apidocSignatureSpan">spdy.Socket.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options &#x26;&#x26; options.readable === false)
    this.readable = false;

  if (options &#x26;&#x26; options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options &#x26;&#x26; options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once(&#x27;end&#x27;, onend);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.Socket.super_.prototype" id="apidoc.module.spdy.Socket.super_.prototype">module spdy.Socket.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype._destroy" id="apidoc.element.spdy.Socket.super_.prototype._destroy">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>_destroy
        <span class="apidocSignatureSpan">(exception, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_destroy = function (exception, cb) {
  debug(&#x27;destroy&#x27;);

  function fireErrorCallbacks(self) {
    if (cb) cb(exception);
    if (exception &#x26;&#x26; !self._writableState.errorEmitted) {
      process.nextTick(emitErrorNT, self, exception);
      self._writableState.errorEmitted = true;
    }
  }

  if (this.destroyed) {
    debug(&#x27;already destroyed, fire error callbacks&#x27;);
    fireErrorCallbacks(this);
    return;
  }

  this.connecting = false;

  this.readable = this.writable = false;

  for (var s = this; s !== null; s = s._parent)
    timers.unenroll(s);

  debug(&#x27;close&#x27;);
  if (this._handle) {
    if (this !== process.stderr)
      debug(&#x27;close handle&#x27;);
    var isException = exception ? true : false;
    // `bytesRead` should be accessible after `.destroy()`
    this[BYTES_READ] = this._handle.bytesRead;

    this._handle.close(() =&#x3e; {
      debug(&#x27;emit close&#x27;);
      this.emit(&#x27;close&#x27;, isException);
    });
    this._handle.onread = noop;
    this._handle = null;
    this._sockname = null;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case Socket.prototype.destroy()
  // is called within callbacks
  this.destroyed = true;
  fireErrorCallbacks(this);

  if (this._server) {
    ;
    debug(&#x27;has server&#x27;);
    this._server._connections--;
    if (this._server._emitCloseIfDrained) {
      this._server._emitCloseIfDrained();
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype._getpeername" id="apidoc.element.spdy.Socket.super_.prototype._getpeername">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>_getpeername
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getpeername = function () {
  if (!this._peername) {
    if (!this._handle || !this._handle.getpeername) {
      return {};
    }
    var out = {};
    var err = this._handle.getpeername(out);
    if (err) return {};  // FIXME(bnoordhuis) Throw?
    this._peername = out;
  }
  return this._peername;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return new Handle(options, stream, socket);
};

Handle.prototype._getPeerName = function _getPeerName() {
var state = this._spdyState;

if (state.rawSocket._getpeername)
  return state.rawSocket.<span class="apidocCodeKeywordSpan">_getpeername</span>();

return null;
};

Handle.prototype._closeCallback = function _closeCallback(callback) {
var state = this._spdyState;
var stream = state.stream;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype._getsockname" id="apidoc.element.spdy.Socket.super_.prototype._getsockname">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>_getsockname
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getsockname = function () {
  if (!this._handle || !this._handle.getsockname) {
    return {};
  }
  if (!this._sockname) {
    var out = {};
    var err = this._handle.getsockname(out);
    if (err) return {};  // FIXME(bnoordhuis) Throw?
    this._sockname = out;
  }
  return this._sockname;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype._onTimeout" id="apidoc.element.spdy.Socket.super_.prototype._onTimeout">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>_onTimeout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onTimeout = function () {
  debug(&#x27;_onTimeout&#x27;);
  this.emit(&#x27;timeout&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype._read" id="apidoc.element.spdy.Socket.super_.prototype._read">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>_read
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read = function (n) {
  debug(&#x27;_read&#x27;);

  if (this.connecting || !this._handle) {
    debug(&#x27;_read wait for connection&#x27;);
    this.once(&#x27;connect&#x27;, () =&#x3e; this._read(n));
  } else if (!this._handle.reading) {
    // not already reading, start the flow
    debug(&#x27;Socket._read readStart&#x27;);
    this._handle.reading = true;
    var err = this._handle.readStart();
    if (err)
      this._destroy(errnoException(err, &#x27;read&#x27;));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype._unrefTimer" id="apidoc.element.spdy.Socket.super_.prototype._unrefTimer">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>_unrefTimer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _unrefTimer() {
  for (var s = this; s !== null; s = s._parent)
    timers._unrefActive(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype._write" id="apidoc.element.spdy.Socket.super_.prototype._write">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>_write
        <span class="apidocSignatureSpan">(data, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write = function (data, encoding, cb) {
  this._writeGeneric(false, data, encoding, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype._writeGeneric" id="apidoc.element.spdy.Socket.super_.prototype._writeGeneric">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>_writeGeneric
        <span class="apidocSignatureSpan">(writev, data, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_writeGeneric = function (writev, data, encoding, cb) {
  // If we are still connecting, then buffer this for later.
  // The Writable logic will buffer up any more writes while
  // waiting for this one to be done.
  if (this.connecting) {
    this._pendingData = data;
    this._pendingEncoding = encoding;
    this.once(&#x27;connect&#x27;, function() {
      this._writeGeneric(writev, data, encoding, cb);
    });
    return;
  }
  this._pendingData = null;
  this._pendingEncoding = &#x27;&#x27;;

  this._unrefTimer();

  if (!this._handle) {
    this._destroy(new Error(&#x27;This socket is closed&#x27;), cb);
    return false;
  }

  var req = new WriteWrap();
  req.handle = this._handle;
  req.oncomplete = afterWrite;
  req.async = false;
  var err;

  if (writev) {
    var chunks = new Array(data.length &#x3c;&#x3c; 1);
    for (var i = 0; i &#x3c; data.length; i++) {
      var entry = data[i];
      chunks[i * 2] = entry.chunk;
      chunks[i * 2 + 1] = entry.encoding;
    }
    err = this._handle.writev(req, chunks);

    // Retain chunks
    if (err === 0) req._chunks = chunks;
  } else {
    var enc;
    if (data instanceof Buffer) {
      enc = &#x27;buffer&#x27;;
    } else {
      enc = encoding;
    }
    err = createWriteReq(req, this._handle, data, enc);
  }

  if (err)
    return this._destroy(errnoException(err, &#x27;write&#x27;, req.error), cb);

  this._bytesDispatched += req.bytes;

  // If it was entirely flushed, we can write some more right now.
  // However, if more is left in the queue, then wait until that clears.
  if (req.async &#x26;&#x26; this._handle.writeQueueSize != 0)
    req.cb = cb;
  else
    cb();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype._writev" id="apidoc.element.spdy.Socket.super_.prototype._writev">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>_writev
        <span class="apidocSignatureSpan">(chunks, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_writev = function (chunks, cb) {
  this._writeGeneric(true, chunks, &#x27;&#x27;, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype.address" id="apidoc.element.spdy.Socket.super_.prototype.address">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>address
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">address = function () {
  return this._getsockname();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  key: &#x22;-----BEGIN RSA PRIVATE KEY-----\nMIIEpAIBAAKCAQEA4YyUIzAnCuSz43HXIPfX60XTeXJLYZZXHnyJIXdBkgE2Ou0F\nhWg0wgbicSiyCoRVQHdFcWhIYQRCq2qu3YKetRxD
/MNY9X0h0cPwf3vYP0Bqowhz\neXPc9DoUl0IwbbolYeHlchgm59w9y/UrjO8fEXxhiBpZnllR2N8C0J6p0T9Itn9y\nxN0iWOuZonrvC8upBquniDnW8X5jwTMUEMbCKBQsVoHZm7R+wfX6BfWTUDGFDh1s\norgMqFarP8TRMYqCFUfM/DFS1CeicpvN6i9SixmboIudSRXOHA+FCh0MrW+JxjDt\nBGHq3AZP0y5+f5ETQvtCWBR1xhv3fHGILshiMQIDAQABAoIBAETE5g3siprprGd2\nuE8XAkB748StsooomptzASSxBc8Mi4pf5kUMxrk5/CTgcZh/TLcBJq0zTI44DFPT\njUmAn/88hQY2UZNX+c3JXjSggAiZDWp0EzE+wGm+o7SSu81Y6jjz9U9aSdJ79mOP\ndx3bcq+UKvCiiBydwzTKmkMdfU2M2Wh/LVerXIlO5P4GsEsbenf53iafj0sHOY4W\n8mf1cWHl8/N+5Eh+0GDIIITGOjmGqNKLZOOg66wjzdY9WbCMTJUWIUjRHjCoG6ZA\nJz+vdsZQVN7M4zy8/fKkE4Vx9NEoJcDfZYa/4uo9r274TK7pJD448nTgRCKOJfMR\nCuxZHXkCgYEA5obXLtRiYXhHyXZOs/Yu9/1Iwm6zHiU66/eFRNGHzTssbPSle1kK\n/2LI3+xiRTI8PfztVP6br5/cWLKhu1ZVebCn+wJJbhpHTfAw1k1YXaCjwHh2l1OF\nPBbT4BPjK2ELNzMMF8veLY6S4yY3bQn8xUmbjQtOYuKDvFgoYAsXQo8CgYEA+nju\nhqAXSDW9yoYQBAXoduEaQH2qNfwRzY6V8rkwISI1seLPlcsd0Kc/VDOSwRdCWOk2\njn5LKPql6FfZ+9MVtPjlVLFjLcEzXttH+PkFtoA9Ffj9cxe3owNjR/tbfoHa19pV\n6+vBZJF48AlkErmVzTNlFJGWh7GtY6LgaOwdbz8CgYEAwhFaLe5WNEASDyQt9YqW\n1+a+zhBrckFdbTEfXGQYs0nRiJgch87aV01OVlSmFiLIXFcFZbxCTIOD+JfJV/DC\nXIO/pqyyLKKqzI4cTw0mCwwlTu8axyJk08VT8RxM7kPwMTQkRhQ2opuYROnzVzRF\nO8FP1lliUBTpWjHNK62qkzkCgYBZg+rLVl+7wOkpfiwvI+VmxyBYuBCi5ol+S10v\nuBuJW+6QupyxzjvDnGI3t47VT3i4yfBjkKNP6/RrSypuo4v4d5OOZy8o5Ql09y2L\nv4PZK4+pUKlT/r/0lHtg+GZEmigaSL+4ZzNgu9TbBKAtSQJOqfWQGlAQAuIS390P\n4oLKhQKBgQDiuimWRSpW3vBepzeH3SuJqm5yx/ms5RUdFH1tc/0vMZR9x/c4Ai2r\ns+1E3KacY/5z9D6t5PWaDj5Sbw8dz0zI7nvnIvufznaaGGqWlrPACQndQLnPrPSr\niFltJhhNQAMlAVOeOz75IQGuC4swdXxbdWXXPrmN9VKGPjClqU+/+w==\n-----END RSA PRIVATE KEY-----&#x22;,
  cert: &#x22;-----BEGIN CERTIFICATE-----\nMIICvDCCAaagAwIBAgIDAQABMAsGCSqGSIb3DQEBDTAVMRMwEQYDVQQDFgpsb2Nh\nbC5ob3N0MB4XDTE2MDkxNzE5MDEyOVoXDTI2MDkxNjE5MDEyOVowFTETMBEGA1UE\nAxYKbG9jYWwuaG9zdDCCASAwCwYJKoZIhvcNAQEBA4IBDwAwggEKAoIBAQDhjJQj\nMCcK5LPjcdcg99frRdN5ckthllcefIkhd0GSATY67QWFaDTCBuJxKLIKhFVAd0Vx\naEhhBEKraq7dgp61HEP8w1j1fSHRw/B/e9g/QGqjCHN5c9z0OhSXQjBtuiVh4eVy\nGCbn3D3L9SuM7x8RfGGIGlmeWVHY3wLQnqnRP0i2f3LE3SJY65mieu8Ly6kGq6eI\nOdbxfmPBMxQQxsIoFCxWgdmbtH7B9foF9ZNQMYUOHWyiuAyoVqs/xNExioIVR8z8\nMVLUJ6Jym83qL1KLGZugi51JFc4cD4UKHQytb4nGMO0EYercBk/TLn5/kRNC+0JY\nFHXGG/d8cYguyGIxAgMBAAGjGzAZMBcGA1UdEQQQMA6CDCoubG9jYWwuaG9zdDAL\nBgkqhkiG9w0BAQ0DggEBAHX840Wl7APZi20i+H+eSL70/tGfld487CBnxfzvECWh\nC+mOfMH9LHSkRhkk+kyosClKO07moUev39EppR7rXhh/fDJLUAbH8Hpb8gJBu0R6\nceQQmqoHCFApqdDF0quvKq5RVatQHfTTuSNd2y/kPD6otnEfxk91rg10dpwd0jii\nv7JBV8cC+z6bDBKn46P8Hpy0k2AY8LgIpUdnmLecxcPAGh0TpGe/2FuYtvPey7vR\nKl4sqjtreZ5kbrqoKRGTU/X2bXHjhF22ZmWO/O0lv1rLrnXCnxQrSTwvXHfNsxkZ\nVqvOQufB7zDfcVrXAeQr7RpyP9qSF9aQwDQj8uio/dI=\n-----END CERTIFICATE-----&#x22;
};

const server = spdy.createServer(options, (req, res) =&#x3e; {
  res.end(&#x27;hello&#x27;);
}).listen(443, () =&#x3e; {
  console.log(&#x27;Listening&#x27;, server.<span class="apidocCodeKeywordSpan">address</span>());
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype.connect" id="apidoc.element.spdy.Socket.super_.prototype.connect">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>connect
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function (options, cb) {
  if (this.write !== Socket.prototype.write)
    this.write = Socket.prototype.write;

  if (options === null || typeof options !== &#x27;object&#x27;) {
    // Old API:
    // connect(port, [host], [cb])
    // connect(path, [cb]);
    var args = new Array(arguments.length);
    for (var i = 0; i &#x3c; arguments.length; i++)
      args[i] = arguments[i];
    args = normalizeConnectArgs(args);
    return Socket.prototype.connect.apply(this, args);
  }

  if (this.destroyed) {
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
    this.destroyed = false;
    this._handle = null;
    this._peername = null;
    this._sockname = null;
  }

  var pipe = !!options.path;
  debug(&#x27;pipe&#x27;, pipe, options.path);

  if (!this._handle) {
    this._handle = pipe ? new Pipe() : new TCP();
    initSocketHandle(this);
  }

  if (typeof cb === &#x27;function&#x27;) {
    this.once(&#x27;connect&#x27;, cb);
  }

  this._unrefTimer();

  this.connecting = true;
  this.writable = true;

  if (pipe) {
    connect(this, options.path);
  } else {
    lookupAndConnect(this, options);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  spdy: {
    &#x27;x-forwarded-for&#x27;: true,
    plain: plain
  }
}, fixtures.keys));

server.listen(fixtures.port, function() {
  var socket = (plain ? net : tls).<span class="apidocCodeKeywordSpan">connect</span>({
    rejectUnauthorized: false,
    port: fixtures.port,
    NPNProtocols: [ npn ]
  }, function() {
    client = transport.connection.create(socket, {
      protocol: protocol,
      isServer: false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype.destroy" id="apidoc.element.spdy.Socket.super_.prototype.destroy">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>destroy
        <span class="apidocSignatureSpan">(exception)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (exception) {
  debug(&#x27;destroy&#x27;, exception);
  this._destroy(exception);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      client.start(version);
      done();
    });
  });
});

afterEach(function(done) {
  client.socket.<span class="apidocCodeKeywordSpan">destroy</span>();
  server.close(done);
});

it(&#x27;should process GET request&#x27;, function(done) {
  var stream = client.request({
    method: &#x27;GET&#x27;,
    path: &#x27;/get&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype.destroySoon" id="apidoc.element.spdy.Socket.super_.prototype.destroySoon">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>destroySoon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroySoon = function () {
  if (this.writable)
    this.end();

  if (this._writableState.finished)
    this.destroy();
  else
    this.once(&#x27;finish&#x27;, this.destroy);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype.end" id="apidoc.element.spdy.Socket.super_.prototype.end">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>end
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (data, encoding) {
  stream.Duplex.prototype.end.call(this, data, encoding);
  this.writable = false;
  ;
  ;

  // just in case we&#x27;re waiting for an EOF.
  if (this.readable &#x26;&#x26; !this._readableState.endEmitted)
    this.read(0);
  else
    maybeDestroy(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      autoSpdy31: false
    }
  }
};

var server = spdy.createServer(options, function(req, res) {
  res.writeHead(200);
  res.<span class="apidocCodeKeywordSpan">end</span>(&#x27;hello world!&#x27;);
});

server.listen(3000);
```

Client:
```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype.listen" id="apidoc.element.spdy.Socket.super_.prototype.listen">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function () {
  debug(&#x27;socket.listen&#x27;);
  this.on(&#x27;connection&#x27;, arguments[0]);
  listen(this, null, null, null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

var server = spdy.createServer(options, function(req, res) {
  res.writeHead(200);
  res.end(&#x27;hello world!&#x27;);
});

server.<span class="apidocCodeKeywordSpan">listen</span>(3000);
```

Client:
```javascript
var spdy = require(&#x27;spdy&#x27;);
var http = require(&#x27;http&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype.read" id="apidoc.element.spdy.Socket.super_.prototype.read">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>read
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (n) {
  if (n === 0)
    return stream.Readable.prototype.read.call(this, n);

  this.read = stream.Readable.prototype.read;
  this._consuming = true;
  return this.read(n);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype.ref" id="apidoc.element.spdy.Socket.super_.prototype.ref">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>ref
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ref = function () {
  if (!this._handle) {
    this.once(&#x27;connect&#x27;, this.ref);
    return this;
  }

  this._handle.ref();

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype.setKeepAlive" id="apidoc.element.spdy.Socket.super_.prototype.setKeepAlive">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>setKeepAlive
        <span class="apidocSignatureSpan">(setting, msecs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setKeepAlive = function (setting, msecs) {
  if (!this._handle) {
    this.once(&#x27;connect&#x27;, () =&#x3e; this.setKeepAlive(setting, msecs));
    return this;
  }

  if (this._handle.setKeepAlive)
    this._handle.setKeepAlive(setting, ~~(msecs / 1000));

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype.setNoDelay" id="apidoc.element.spdy.Socket.super_.prototype.setNoDelay">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>setNoDelay
        <span class="apidocSignatureSpan">(enable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setNoDelay = function (enable) {
  if (!this._handle) {
    this.once(&#x27;connect&#x27;,
              enable ? this.setNoDelay : () =&#x3e; this.setNoDelay(enable));
    return this;
  }

  // backwards compatibility: assume true when `enable` is omitted
  if (this._handle.setNoDelay)
    this._handle.setNoDelay(enable === undefined ? true : !!enable);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var socket = this.createConnection(util._extend({
  NPNProtocols: protocols,
  ALPNProtocols: protocols,
  servername: options.servername || options.host
}, options));
state.socket = socket;

socket.<span class="apidocCodeKeywordSpan">setNoDelay</span>(true);

function onError(err) {
  return callback(err);
}
socket.on(&#x27;error&#x27;, onError);

socket.on(state.secure ? &#x27;secureConnect&#x27; : &#x27;connect&#x27;, function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype.setTimeout" id="apidoc.element.spdy.Socket.super_.prototype.setTimeout">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>setTimeout
        <span class="apidocSignatureSpan">(msecs, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setTimeout = function (msecs, callback) {
  if (msecs === 0) {
    timers.unenroll(this);
    if (callback) {
      this.removeListener(&#x27;timeout&#x27;, callback);
    }
  } else {
    timers.enroll(this, msecs);
    timers._unrefActive(this);
    if (callback) {
      this.once(&#x27;timeout&#x27;, callback);
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype.unref" id="apidoc.element.spdy.Socket.super_.prototype.unref">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>unref
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unref = function () {
  if (!this._handle) {
    this.once(&#x27;connect&#x27;, this.unref);
    return this;
  }

  this._handle.unref();

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.Socket.super_.prototype.write" id="apidoc.element.spdy.Socket.super_.prototype.write">
        function <span class="apidocSignatureSpan">spdy.Socket.super_.prototype.</span>write
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (chunk, encoding, cb) {
  if (typeof chunk !== &#x27;string&#x27; &#x26;&#x26; !(chunk instanceof Buffer)) {
    throw new TypeError(
      &#x27;Invalid data, chunk must be a string or buffer, not &#x27; + typeof chunk);
  }
  return stream.Duplex.prototype.write.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
var req = http.request({ agent: spdyAgent, /* ... */ }).function (res) {
  // On server&#x27;s trailing headers
  res.on(&#x27;trailers&#x27;, function(headers) {
    // ...
  });
});
req.<span class="apidocCodeKeywordSpan">write</span>(&#x27;stuff&#x27;);
req.addTrailers({ /* ... */ });
req.end();
```

### Options

All options supported by [tls][2] work with node-spdy.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.agent" id="apidoc.module.spdy.agent">module spdy.agent</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.agent.Agent" id="apidoc.element.spdy.agent.Agent">
        function <span class="apidocSignatureSpan">spdy.agent.</span>Agent
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Agent(options) {
  this._init(base, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.agent.PlainAgent" id="apidoc.element.spdy.agent.PlainAgent">
        function <span class="apidocSignatureSpan">spdy.agent.</span>PlainAgent
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Agent(options) {
  this._init(base, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.agent.create" id="apidoc.element.spdy.agent.create">
        function <span class="apidocSignatureSpan">spdy.agent.</span>create
        <span class="apidocSignatureSpan">(base, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(base, options) {
  if (typeof base === &#x27;object&#x27;) {
    options = base;
    base = null;
  }

  if (base)
    return instantiate(base).create(options);

  if (options.spdy &#x26;&#x26; options.spdy.plain)
    return exports.PlainAgent.create(options);
  else
    return exports.Agent.create(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

server.listen(fixtures.port, function() {
  var socket = (plain ? net : tls).connect({
    rejectUnauthorized: false,
    port: fixtures.port,
    NPNProtocols: [ npn ]
  }, function() {
    client = transport.connection.<span class="apidocCodeKeywordSpan">create</span>(socket, {
      protocol: protocol,
      isServer: false
    });
    client.start(version);
    done();
  });
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.agent.PlainAgent" id="apidoc.module.spdy.agent.PlainAgent">module spdy.agent.PlainAgent</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.agent.PlainAgent.PlainAgent" id="apidoc.element.spdy.agent.PlainAgent.PlainAgent">
        function <span class="apidocSignatureSpan">spdy.agent.</span>PlainAgent
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Agent(options) {
  this._init(base, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.agent.PlainAgent.create" id="apidoc.element.spdy.agent.PlainAgent.create">
        function <span class="apidocSignatureSpan">spdy.agent.PlainAgent.</span>create
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(options) {
  return new Agent(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

server.listen(fixtures.port, function() {
  var socket = (plain ? net : tls).connect({
    rejectUnauthorized: false,
    port: fixtures.port,
    NPNProtocols: [ npn ]
  }, function() {
    client = transport.connection.<span class="apidocCodeKeywordSpan">create</span>(socket, {
      protocol: protocol,
      isServer: false
    });
    client.start(version);
    done();
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.agent.PlainAgent.super_" id="apidoc.element.spdy.agent.PlainAgent.super_">
        function <span class="apidocSignatureSpan">spdy.agent.PlainAgent.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Agent(options) {
  if (!(this instanceof Agent))
    return new Agent(options);

  EventEmitter.call(this);

  var self = this;

  self.defaultPort = 80;
  self.protocol = &#x27;http:&#x27;;

  self.options = util._extend({}, options);

  // don&#x27;t confuse net and make it think that we&#x27;re connecting to a pipe
  self.options.path = null;
  self.requests = {};
  self.sockets = {};
  self.freeSockets = {};
  self.keepAliveMsecs = self.options.keepAliveMsecs || 1000;
  self.keepAlive = self.options.keepAlive || false;
  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets;
  self.maxFreeSockets = self.options.maxFreeSockets || 256;

  self.on(&#x27;free&#x27;, function(socket, options) {
    var name = self.getName(options);
    debug(&#x27;agent.on(free)&#x27;, name);

    if (socket.writable &#x26;&#x26;
        self.requests[name] &#x26;&#x26; self.requests[name].length) {
      self.requests[name].shift().onSocket(socket);
      if (self.requests[name].length === 0) {
        // don&#x27;t leak
        delete self.requests[name];
      }
    } else {
      // If there are no pending requests, then put it in
      // the freeSockets pool, but only if we&#x27;re allowed to do so.
      var req = socket._httpMessage;
      if (req &#x26;&#x26;
          req.shouldKeepAlive &#x26;&#x26;
          socket.writable &#x26;&#x26;
          self.keepAlive) {
        var freeSockets = self.freeSockets[name];
        var freeLen = freeSockets ? freeSockets.length : 0;
        var count = freeLen;
        if (self.sockets[name])
          count += self.sockets[name].length;

        if (count &#x3e; self.maxSockets || freeLen &#x3e;= self.maxFreeSockets) {
          socket.destroy();
        } else {
          freeSockets = freeSockets || [];
          self.freeSockets[name] = freeSockets;
          socket.setKeepAlive(true, self.keepAliveMsecs);
          socket.unref();
          socket._httpMessage = null;
          self.removeSocket(socket, options);
          freeSockets.push(socket);
        }
      } else {
        socket.destroy();
      }
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.agent.PlainAgent.prototype" id="apidoc.module.spdy.agent.PlainAgent.prototype">module spdy.agent.PlainAgent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.agent.PlainAgent.prototype._connect" id="apidoc.element.spdy.agent.PlainAgent.prototype._connect">
        function <span class="apidocSignatureSpan">spdy.agent.PlainAgent.prototype.</span>_connect
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _connect(options, callback) {
  var state = this._spdyState;

  var protocols = state.options.protocols || [
    &#x27;h2&#x27;,
    &#x27;spdy/3.1&#x27;, &#x27;spdy/3&#x27;, &#x27;spdy/2&#x27;,
    &#x27;http/1.1&#x27;, &#x27;http/1.0&#x27;
  ];

  // TODO(indutny): reconnect automatically?
  var socket = this.createConnection(util._extend({
    NPNProtocols: protocols,
    ALPNProtocols: protocols,
    servername: options.servername || options.host
  }, options));
  state.socket = socket;

  socket.setNoDelay(true);

  function onError(err) {
    return callback(err);
  }
  socket.on(&#x27;error&#x27;, onError);

  socket.on(state.secure ? &#x27;secureConnect&#x27; : &#x27;connect&#x27;, function() {
    socket.removeListener(&#x27;error&#x27;, onError);

    var protocol;
    if (state.secure) {
      protocol = socket.npnProtocol ||
                 socket.alpnProtocol ||
                 state.options.protocol;
    } else {
      protocol = state.options.protocol;
    }

    // HTTP server - kill socket and switch to the fallback mode
    if (!protocol || protocol === &#x27;http/1.1&#x27; || protocol === &#x27;http/1.0&#x27;) {
      debug(&#x27;activating fallback&#x27;);
      socket.destroy();
      state.fallback = true;
      return;
    }

    debug(&#x27;connected protocol=%j&#x27;, protocol);
    var connection = transport.connection.create(socket, util._extend({
      protocol: /spdy/.test(protocol) ? &#x27;spdy&#x27; : &#x27;http2&#x27;,
      isServer: false
    }, state.options.connection || {}));

    // Set version when we are certain
    if (protocol === &#x27;h2&#x27;) {
      connection.start(4);
    } else if (protocol === &#x27;spdy/3.1&#x27;) {
      connection.start(3.1);
    } else if (protocol === &#x27;spdy/3&#x27;) {
      connection.start(3);
    } else if (protocol === &#x27;spdy/2&#x27;) {
      connection.start(2);
    } else {
      socket.destroy();
      callback(new Error(&#x27;Unexpected protocol: &#x27; + protocol));
      return;
    }

    if (state.options[&#x27;x-forwarded-for&#x27;] !== undefined)
      connection.sendXForwardedFor(state.options[&#x27;x-forwarded-for&#x27;]);

    callback(null, connection);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  state.socket = null;
  state.connection = null;

  // No chunked encoding
  this.keepAlive = false;

  var self = this;
  this.<span class="apidocCodeKeywordSpan">_connect</span>(options, function(err, connection) {
    if (err)
      return self.emit(&#x27;error&#x27;, err);

    state.connection = connection;
    self.emit(&#x27;_connect&#x27;);
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.agent.PlainAgent.prototype._createSocket" id="apidoc.element.spdy.agent.PlainAgent.prototype._createSocket">
        function <span class="apidocSignatureSpan">spdy.agent.PlainAgent.prototype.</span>_createSocket
        <span class="apidocSignatureSpan">(req, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _createSocket(req, options, callback) {
  var state = this._spdyState;
  if (state.fallback)
    return state.createSocket(req, options);

  var handle = spdy.handle.create(null, null, state.socket);

  var socketOptions = {
    handle: handle,
    allowHalfOpen: true
  };

  var socket;
  if (state.secure)
    socket = new spdy.Socket(state.socket, socketOptions);
  else
    socket = new net.Socket(socketOptions);

  handle.assignSocket(socket);
  handle.assignClientRequest(req);

  // Create stream only once `req.end()` is called
  var self = this;
  handle.once(&#x27;needStream&#x27;, function() {
    if (state.connection === null) {
      self.once(&#x27;_connect&#x27;, function() {
        handle.setStream(self._createStream(req, handle));
      });
    } else {
      handle.setStream(self._createStream(req, handle));
    }
  });

  // Yes, it is in reverse
  req.on(&#x27;response&#x27;, function(res) {
    handle.assignRequest(res);
  });
  handle.assignResponse(req);

  // Handle PUSH
  req.addListener(&#x27;newListener&#x27;, spdy.request.onNewListener);

  // For v0.8
  socket.readable = true;
  socket.writable = true;

  if (callback)
    return callback(null, socket);

  return socket;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  proto.createSocket = proto._createSocket;
} else {
  proto.createSocket = function createSocket(name, host, port, addr, req) {
    var state = this._spdyState;
    if (state.fallback)
      return state.createSocket(name, host, port, addr, req);

    return this.<span class="apidocCodeKeywordSpan">_createSocket</span>(req, {
      host: host,
      port: port
    });
  };
}

proto._createStream = function _createStream(req, handle) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.agent.PlainAgent.prototype._createStream" id="apidoc.element.spdy.agent.PlainAgent.prototype._createStream">
        function <span class="apidocSignatureSpan">spdy.agent.PlainAgent.prototype.</span>_createStream
        <span class="apidocSignatureSpan">(req, handle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _createStream(req, handle) {
  var state = this._spdyState;

  var self = this;
  return state.connection.reserveStream({
    method: req.method,
    path: req.path,
    headers: req._headers,
    host: state.host
  }, function(err, stream) {
    if (err)
      return self.emit(&#x27;error&#x27;, err);

    stream.on(&#x27;response&#x27;, function(status, headers) {
      handle.emitResponse(status, headers);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
handle.assignClientRequest(req);

// Create stream only once `req.end()` is called
var self = this;
handle.once(&#x27;needStream&#x27;, function() {
  if (state.connection === null) {
    self.once(&#x27;_connect&#x27;, function() {
      handle.setStream(self.<span class="apidocCodeKeywordSpan">_createStream</span>(req, handle));
    });
  } else {
    handle.setStream(self._createStream(req, handle));
  }
});

// Yes, it is in reverse
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.agent.PlainAgent.prototype._getCreateSocket" id="apidoc.element.spdy.agent.PlainAgent.prototype._getCreateSocket">
        function <span class="apidocSignatureSpan">spdy.agent.PlainAgent.prototype.</span>_getCreateSocket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _getCreateSocket() {
  // Find super&#x27;s `createSocket` method
  var createSocket;
  var cons = this.constructor.super_;
  do {
    createSocket = cons.prototype.createSocket;

    if (cons.super_ === EventEmitter || !cons.super_)
      break;
    cons = cons.super_;
  } while (!createSocket);
  if (!createSocket)
    createSocket = http.Agent.prototype.createSocket;

  assert(createSocket, &#x27;.createSocket() method not found&#x27;);

  return createSocket;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var state = {};
this._spdyState = state;

state.host = options.host;
state.options = options.spdy || {};
state.secure = this instanceof https.Agent;
state.fallback = false;
state.createSocket = this.<span class="apidocCodeKeywordSpan">_getCreateSocket</span>();
state.socket = null;
state.connection = null;

// No chunked encoding
this.keepAlive = false;

var self = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.agent.PlainAgent.prototype._init" id="apidoc.element.spdy.agent.PlainAgent.prototype._init">
        function <span class="apidocSignatureSpan">spdy.agent.PlainAgent.prototype.</span>_init
        <span class="apidocSignatureSpan">(base, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _init(base, options) {
  base.call(this, options);

  var state = {};
  this._spdyState = state;

  state.host = options.host;
  state.options = options.spdy || {};
  state.secure = this instanceof https.Agent;
  state.fallback = false;
  state.createSocket = this._getCreateSocket();
  state.socket = null;
  state.connection = null;

  // No chunked encoding
  this.keepAlive = false;

  var self = this;
  this._connect(options, function(err, connection) {
    if (err)
      return self.emit(&#x27;error&#x27;, err);

    state.connection = connection;
    self.emit(&#x27;_connect&#x27;);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         /^v0\.12\./.test(process.version) ? &#x27;normal&#x27; :
         &#x27;modern&#x27;;

var proto = {};

function instantiate(base) {
function Agent(options) {
  this.<span class="apidocCodeKeywordSpan">_init</span>(base, options);
}
util.inherits(Agent, base);

Agent.create = function create(options) {
  return new Agent(options);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.agent.PlainAgent.prototype.close" id="apidoc.element.spdy.agent.PlainAgent.prototype.close">
        function <span class="apidocSignatureSpan">spdy.agent.PlainAgent.prototype.</span>close
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function close(callback) {
  var state = this._spdyState;

  if (state.connection === null) {
    this.once(&#x27;_connect&#x27;, function() {
      this.close(callback);
    });
    return;
  }

  state.connection.end(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  agent: agent
}, function(response) {
  console.log(&#x27;yikes&#x27;);
  // Here it goes like with any other node.js HTTP request
  // ...
  // And once we&#x27;re done - we may close TCP connection to server
  // NOTE: All non-closed requests will die!
  agent.<span class="apidocCodeKeywordSpan">close</span>();
}).end();
```

Please note that if you use a custom agent, by default all connection-level
errors will result in an uncaught exception. To handle these errors subscribe
to the `error` event and re-emit the captured error:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.agent.PlainAgent.prototype.createSocket" id="apidoc.element.spdy.agent.PlainAgent.prototype.createSocket">
        function <span class="apidocSignatureSpan">spdy.agent.PlainAgent.prototype.</span>createSocket
        <span class="apidocSignatureSpan">(req, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _createSocket(req, options, callback) {
  var state = this._spdyState;
  if (state.fallback)
    return state.createSocket(req, options);

  var handle = spdy.handle.create(null, null, state.socket);

  var socketOptions = {
    handle: handle,
    allowHalfOpen: true
  };

  var socket;
  if (state.secure)
    socket = new spdy.Socket(state.socket, socketOptions);
  else
    socket = new net.Socket(socketOptions);

  handle.assignSocket(socket);
  handle.assignClientRequest(req);

  // Create stream only once `req.end()` is called
  var self = this;
  handle.once(&#x27;needStream&#x27;, function() {
    if (state.connection === null) {
      self.once(&#x27;_connect&#x27;, function() {
        handle.setStream(self._createStream(req, handle));
      });
    } else {
      handle.setStream(self._createStream(req, handle));
    }
  });

  // Yes, it is in reverse
  req.on(&#x27;response&#x27;, function(res) {
    handle.assignRequest(res);
  });
  handle.assignResponse(req);

  // Handle PUSH
  req.addListener(&#x27;newListener&#x27;, spdy.request.onNewListener);

  // For v0.8
  socket.readable = true;
  socket.writable = true;

  if (callback)
    return callback(null, socket);

  return socket;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (cons.super_ === EventEmitter || !cons.super_)
    break;
  cons = cons.super_;
} while (!createSocket);
if (!createSocket)
  createSocket = http.Agent.prototype.createSocket;

assert(createSocket, &#x27;.<span class="apidocCodeKeywordSpan">createSocket</span>() method not found&#x27;);

return createSocket;
};

proto._connect = function _connect(options, callback) {
var state = this._spdyState;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.handle" id="apidoc.module.spdy.handle">module spdy.handle</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.handle.handle" id="apidoc.element.spdy.handle.handle">
        function <span class="apidocSignatureSpan">spdy.</span>handle
        <span class="apidocSignatureSpan">(options, stream, socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Handle(options, stream, socket) {
  var state = {};
  this._spdyState = state;

  state.options = options || {};

  state.stream = stream;
  state.socket = null;
  state.rawSocket = socket || stream.connection.socket;
  state.deceiver = null;
  state.ending = false;

  var self = this;
  thing.call(this, stream, {
    getPeerName: function() {
      return self._getPeerName();
    },
    close: function(callback) {
      return self._closeCallback(callback);
    }
  });

  if (!state.stream) {
    this.on(&#x27;stream&#x27;, function(stream) {
      state.stream = stream;
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.create" id="apidoc.element.spdy.handle.create">
        function <span class="apidocSignatureSpan">spdy.handle.</span>create
        <span class="apidocSignatureSpan">(options, stream, socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(options, stream, socket) {
  return new Handle(options, stream, socket);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

server.listen(fixtures.port, function() {
  var socket = (plain ? net : tls).connect({
    rejectUnauthorized: false,
    port: fixtures.port,
    NPNProtocols: [ npn ]
  }, function() {
    client = transport.connection.<span class="apidocCodeKeywordSpan">create</span>(socket, {
      protocol: protocol,
      isServer: false
    });
    client.start(version);
    done();
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_" id="apidoc.element.spdy.handle.super_">
        function <span class="apidocSignatureSpan">spdy.handle.</span>super_
        <span class="apidocSignatureSpan">(stream, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Handle(stream, options) {
  EventEmitter.call(this);

  this._stream = stream;
  this._flowing = false;
  this._reading = false;
  this._options = options || {};

  this.onread = null;

  // Pending requests
  this.pending = new Queue();

  // Start handle once `onread` is set
  if (mode === &#x27;rusty&#x27;) {
    var self = this;
    Object.defineProperty(this, &#x27;onread&#x27;, {
      set: function(value) {
        Object.defineProperty(self, &#x27;onread&#x27;, {
          value: value
        });
        process.nextTick(function() {
          self.readStart();
        });
      }
    });
  }

  // NOTE: v0.8 has some odd .pause()/.resume() semantics in http.js
  if (mode === &#x27;rusty&#x27;)
    this.writeQueueSize = 0;
  else if (mode !== &#x27;modern&#x27;)
    this.writeQueueSize = 1;

  if (mode === &#x27;rusty&#x27;) {
    if (this._stream)
      this._rustyInit();
    else
      this.once(&#x27;stream&#x27;, this._rustyInit);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.handle.prototype" id="apidoc.module.spdy.handle.prototype">module spdy.handle.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.handle.prototype._closeCallback" id="apidoc.element.spdy.handle.prototype._closeCallback">
        function <span class="apidocSignatureSpan">spdy.handle.prototype.</span>_closeCallback
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _closeCallback(callback) {
  var state = this._spdyState;
  var stream = state.stream;

  if (state.ending) {
    // The .end() method of the stream may be called by us or by the
    // .shutdown() method in our super-class. If the latter has already been
    // called, then calling the .end() method below will have no effect, with
    // the result that the callback will never get executed, leading to an ever
    // so subtle memory leak.
    if (stream._writableState.finished) {
      // NOTE: it is important to call `setImmediate` instead of `nextTick`,
      // since this is how regular `handle.close()` works in node.js core.
      //
      // Using `nextTick` will lead to `net.Socket` emitting `close` before
      // `end` on UV_EOF. This results in aborted request without `end` event.
      setImmediate(callback);
    } else if (stream._writableState.ending) {
      stream.once(&#x27;finish&#x27;, function() {
        callback(null);
      });
    } else {
      stream.end(callback);
    }
  } else {
    stream.abort(callback);
  }

  // Only a single end is allowed
  state.ending = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var self = this;
thing.call(this, stream, {
  getPeerName: function() {
    return self._getPeerName();
  },
  close: function(callback) {
    return self.<span class="apidocCodeKeywordSpan">_closeCallback</span>(callback);
  }
});

if (!state.stream) {
  this.on(&#x27;stream&#x27;, function(stream) {
    state.stream = stream;
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.prototype._getPeerName" id="apidoc.element.spdy.handle.prototype._getPeerName">
        function <span class="apidocSignatureSpan">spdy.handle.prototype.</span>_getPeerName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _getPeerName() {
  var state = this._spdyState;

  if (state.rawSocket._getpeername)
    return state.rawSocket._getpeername();

  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
state.rawSocket = socket || stream.connection.socket;
state.deceiver = null;
state.ending = false;

var self = this;
thing.call(this, stream, {
  getPeerName: function() {
    return self.<span class="apidocCodeKeywordSpan">_getPeerName</span>();
  },
  close: function(callback) {
    return self._closeCallback(callback);
  }
});

if (!state.stream) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.prototype._transformHeaders" id="apidoc.element.spdy.handle.prototype._transformHeaders">
        function <span class="apidocSignatureSpan">spdy.handle.prototype.</span>_transformHeaders
        <span class="apidocSignatureSpan">(kind, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _transformHeaders(kind, headers) {
  var state = this._spdyState;

  var res = {};
  var keys = Object.keys(headers);

  if (kind === &#x27;request&#x27; &#x26;&#x26; state.options[&#x27;x-forwarded-for&#x27;]) {
    var xforwarded = state.stream.connection.getXForwardedFor();
    if (xforwarded !== null)
      res[&#x27;x-forwarded-for&#x27;] = xforwarded;
  }

  for (var i = 0; i &#x3c; keys.length; i++) {
    var key = keys[i];
    var value = headers[key];

    if (key === &#x27;:authority&#x27;)
      res.host = value;
    if (/^:/.test(key))
      continue;

    res[key] = value;
  }
  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Handle.prototype.emitRequest = function emitRequest() {
var state = this._spdyState;
var stream = state.stream;

state.deceiver.emitRequest({
  method: stream.method,
  path: stream.path,
  headers: this.<span class="apidocCodeKeywordSpan">_transformHeaders</span>(&#x27;request&#x27;, stream.headers)
});
};

Handle.prototype.emitResponse = function emitResponse(status, headers) {
var state = this._spdyState;

state.deceiver.emitResponse({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.prototype.assignClientRequest" id="apidoc.element.spdy.handle.prototype.assignClientRequest">
        function <span class="apidocSignatureSpan">spdy.handle.prototype.</span>assignClientRequest
        <span class="apidocSignatureSpan">(req)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function assignClientRequest(req) {
  var state = this._spdyState;
  var oldEnd = req.end;
  var oldSend = req._send;

  // Catch the headers before request will be sent
  var self = this;

  // For old nodes
  if (thing.mode !== &#x27;modern&#x27;) {
    req.end = function end() {
      this.end = oldEnd;

      this._send(&#x27;&#x27;);

      return this.end.apply(this, arguments);
    };
  }

  req._send = function send(data) {
    this._headerSent = true;

    // for v0.10 and below, otherwise it will set `hot = false` and include
    // headers in first write
    this._header = &#x27;ignore me&#x27;;

    // To prevent exception
    this.connection = state.socket;

    // It is very important to leave this here, otherwise it will be executed
    // on a next tick, after `_send` will perform write
    self.getStream(function(stream) {
      stream.send();
    });

    // We are ready to create stream
    self.emit(&#x27;needStream&#x27;);

    req._send = oldSend;

    // Ignore empty writes
    if (req.method === &#x27;GET&#x27; &#x26;&#x26; data.length === 0)
      return;

    return req._send.apply(this, arguments);
  };

  // No chunked encoding
  req.useChunkedEncodingByDefault = false;

  req.on(&#x27;finish&#x27;, function() {
    req.socket.end();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var socket;
if (state.secure)
  socket = new spdy.Socket(state.socket, socketOptions);
else
  socket = new net.Socket(socketOptions);

handle.assignSocket(socket);
handle.<span class="apidocCodeKeywordSpan">assignClientRequest</span>(req);

// Create stream only once `req.end()` is called
var self = this;
handle.once(&#x27;needStream&#x27;, function() {
  if (state.connection === null) {
    self.once(&#x27;_connect&#x27;, function() {
      handle.setStream(self._createStream(req, handle));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.prototype.assignRequest" id="apidoc.element.spdy.handle.prototype.assignRequest">
        function <span class="apidocSignatureSpan">spdy.handle.prototype.</span>assignRequest
        <span class="apidocSignatureSpan">(req)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function assignRequest(req) {
  // Emit trailing headers
  this.getStream(function(stream) {
    stream.on(&#x27;headers&#x27;, function(headers) {
      req.emit(&#x27;trailers&#x27;, headers);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    handle.setStream(self._createStream(req, handle));
  }
});

// Yes, it is in reverse
req.on(&#x27;response&#x27;, function(res) {
  handle.<span class="apidocCodeKeywordSpan">assignRequest</span>(res);
});
handle.assignResponse(req);

// Handle PUSH
req.addListener(&#x27;newListener&#x27;, spdy.request.onNewListener);

// For v0.8
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.prototype.assignResponse" id="apidoc.element.spdy.handle.prototype.assignResponse">
        function <span class="apidocSignatureSpan">spdy.handle.prototype.</span>assignResponse
        <span class="apidocSignatureSpan">(res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function assignResponse(res) {
  var self = this;

  res.addTrailers = function addTrailers(headers) {
    self.getStream(function(stream) {
      stream.sendHeaders(headers);
    });
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
});

// Yes, it is in reverse
req.on(&#x27;response&#x27;, function(res) {
  handle.assignRequest(res);
});
handle.<span class="apidocCodeKeywordSpan">assignResponse</span>(req);

// Handle PUSH
req.addListener(&#x27;newListener&#x27;, spdy.request.onNewListener);

// For v0.8
socket.readable = true;
socket.writable = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.prototype.assignSocket" id="apidoc.element.spdy.handle.prototype.assignSocket">
        function <span class="apidocSignatureSpan">spdy.handle.prototype.</span>assignSocket
        <span class="apidocSignatureSpan">(socket, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function assignSocket(socket, options) {
  var state = this._spdyState;

  state.socket = socket;
  state.deceiver = httpDeceiver.create(socket, options);

  function onStreamError(err) {
    state.socket.emit(&#x27;error&#x27;, err);
  }

  this.getStream(function(stream) {
    stream.on(&#x27;error&#x27;, onStreamError);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var socket;
if (state.secure)
  socket = new spdy.Socket(state.socket, socketOptions);
else
  socket = new net.Socket(socketOptions);

handle.<span class="apidocCodeKeywordSpan">assignSocket</span>(socket);
handle.assignClientRequest(req);

// Create stream only once `req.end()` is called
var self = this;
handle.once(&#x27;needStream&#x27;, function() {
  if (state.connection === null) {
    self.once(&#x27;_connect&#x27;, function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.prototype.emitRequest" id="apidoc.element.spdy.handle.prototype.emitRequest">
        function <span class="apidocSignatureSpan">spdy.handle.prototype.</span>emitRequest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emitRequest() {
  var state = this._spdyState;
  var stream = state.stream;

  state.deceiver.emitRequest({
    method: stream.method,
    path: stream.path,
    headers: this._transformHeaders(&#x27;request&#x27;, stream.headers)
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return res;
};

Handle.prototype.emitRequest = function emitRequest() {
  var state = this._spdyState;
  var stream = state.stream;

  state.deceiver.<span class="apidocCodeKeywordSpan">emitRequest</span>({
    method: stream.method,
    path: stream.path,
    headers: this._transformHeaders(&#x27;request&#x27;, stream.headers)
  });
};

Handle.prototype.emitResponse = function emitResponse(status, headers) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.prototype.emitResponse" id="apidoc.element.spdy.handle.prototype.emitResponse">
        function <span class="apidocSignatureSpan">spdy.handle.prototype.</span>emitResponse
        <span class="apidocSignatureSpan">(status, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emitResponse(status, headers) {
  var state = this._spdyState;

  state.deceiver.emitResponse({
    status: status,
    headers: this._transformHeaders(&#x27;response&#x27;, headers)
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    headers: req._headers,
    host: state.host
  }, function(err, stream) {
    if (err)
      return self.emit(&#x27;error&#x27;, err);

    stream.on(&#x27;response&#x27;, function(status, headers) {
      handle.<span class="apidocCodeKeywordSpan">emitResponse</span>(status, headers);
    });
  });
};

// Public APIs

proto.close = function close(callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.prototype.getStream" id="apidoc.element.spdy.handle.prototype.getStream">
        function <span class="apidocSignatureSpan">spdy.handle.prototype.</span>getStream
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getStream(callback) {
  var state = this._spdyState;

  if (!callback) {
    assert(state.stream);
    return state.stream;
  }

  if (state.stream) {
    process.nextTick(function() {
      callback(state.stream);
    });
    return;
  }

  this.on(&#x27;stream&#x27;, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
state.socket = socket;
state.deceiver = httpDeceiver.create(socket, options);

function onStreamError(err) {
  state.socket.emit(&#x27;error&#x27;, err);
}

this.<span class="apidocCodeKeywordSpan">getStream</span>(function(stream) {
  stream.on(&#x27;error&#x27;, onStreamError);
});
};

Handle.prototype.assignClientRequest = function assignClientRequest(req) {
var state = this._spdyState;
var oldEnd = req.end;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.handle.super_" id="apidoc.module.spdy.handle.super_">module spdy.handle.super_</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.handle.super_.super_" id="apidoc.element.spdy.handle.super_.super_">
        function <span class="apidocSignatureSpan">spdy.handle.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_.create" id="apidoc.element.spdy.handle.super_.create">
        function <span class="apidocSignatureSpan">spdy.handle.super_.</span>create
        <span class="apidocSignatureSpan">(stream, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(stream, options) {
  return new Handle(stream, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

server.listen(fixtures.port, function() {
  var socket = (plain ? net : tls).connect({
    rejectUnauthorized: false,
    port: fixtures.port,
    NPNProtocols: [ npn ]
  }, function() {
    client = transport.connection.<span class="apidocCodeKeywordSpan">create</span>(socket, {
      protocol: protocol,
      isServer: false
    });
    client.start(version);
    done();
  });
});
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.handle.super_.prototype" id="apidoc.module.spdy.handle.super_.prototype">module spdy.handle.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.handle.super_.prototype._close" id="apidoc.element.spdy.handle.super_.prototype._close">
        function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>_close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _close() {
  var list = this._pendingList();

  var self = this;
  setImmediate(function() {
    for (var i = 0; i &#x3c; list.length; i++) {
      var req = list[i];
      req.oncomplete(uv.UV_ECANCELED, self, req);
    }
  });

  this.readStop();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_.prototype._flow" id="apidoc.element.spdy.handle.super_.prototype._flow">
        function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>_flow
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flow() {
  var self = this;
  this._stream.on(&#x27;data&#x27;, function(chunk) {
    self.onread(chunk.length, chunk);
  });

  this._stream.on(&#x27;end&#x27;, function() {
    self.onread(uv.UV_EOF, new Buffer(0));
  });

  this._stream.on(&#x27;close&#x27;, function() {
    setImmediate(function() {
      if (self._reading)
        self.onread(uv.UV_ECONNRESET, new Buffer(0));
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_.prototype._pendingList" id="apidoc.element.spdy.handle.super_.prototype._pendingList">
        function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>_pendingList
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _pendingList() {
  var list = [];
  while (!this.pending.isEmpty())
    list.push(this.pending.first().dequeue());
  return list;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_.prototype._queueReq" id="apidoc.element.spdy.handle.super_.prototype._queueReq">
        function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>_queueReq
        <span class="apidocSignatureSpan">(type, req)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _queueReq(type, req) {
  return this.pending.append(type, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_.prototype._shutdown" id="apidoc.element.spdy.handle.super_.prototype._shutdown">
        function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>_shutdown
        <span class="apidocSignatureSpan">(wrap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _shutdown(wrap) {
  var self = this;
  this._stream.end(function() {
    var req = wrap.dequeue();
    if (!req)
      return;

    req.oncomplete(0, self, req);
  });
  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_.prototype._writeEnc" id="apidoc.element.spdy.handle.super_.prototype._writeEnc">
        function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>_writeEnc
        <span class="apidocSignatureSpan">(wrap, req, data, enc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _writeEnc(wrap, req, data, enc) {
  var self = this;

  req.async = true;
  req.bytes = data.length;

  if (wrap.isEmpty())
    return 0;

  this._stream.write(data, enc, function() {
    var req = wrap.dequeue();
    if (!req)
      return;
    req.oncomplete(0, self, req);
  });

  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_.prototype.close" id="apidoc.element.spdy.handle.super_.prototype.close">
        function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>close
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function close(callback) {
  this._close();

  if (!this._stream) {
    this.once(&#x27;stream&#x27;, function() {
      this.close(callback);
    });
    return 0;
  }

  if (this._options.close)
    this._options.close(callback);
  else
    process.nextTick(callback);

  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  agent: agent
}, function(response) {
  console.log(&#x27;yikes&#x27;);
  // Here it goes like with any other node.js HTTP request
  // ...
  // And once we&#x27;re done - we may close TCP connection to server
  // NOTE: All non-closed requests will die!
  agent.<span class="apidocCodeKeywordSpan">close</span>();
}).end();
```

Please note that if you use a custom agent, by default all connection-level
errors will result in an uncaught exception. To handle these errors subscribe
to the `error` event and re-emit the captured error:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_.prototype.getpeername" id="apidoc.element.spdy.handle.super_.prototype.getpeername">
        function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>getpeername
        <span class="apidocSignatureSpan">(out)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getpeername(out) {
  var res = this.getsockname();
  if (!res)
    return -1;

  Object.keys(res).forEach(function(key) {
    out[key] = res[key];
  });

  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_.prototype.getsockname" id="apidoc.element.spdy.handle.super_.prototype.getsockname">
        function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>getsockname
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getsockname() {
  if (this._options.getPeerName)
    return this._options.getPeerName();
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_.prototype.readStart" id="apidoc.element.spdy.handle.super_.prototype.readStart">
        function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>readStart
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readStart() {
  this._reading = true;

  if (!this._stream) {
    this.once(&#x27;stream&#x27;, this.readStart);
    return 0;
  }

  if (!this._flowing) {
    this._flowing = true;
    this._flow();
  }

  this._stream.resume();
  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_.prototype.readStop" id="apidoc.element.spdy.handle.super_.prototype.readStop">
        function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>readStop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readStop() {
  this._reading = false;

  if (!this._stream) {
    this.once(&#x27;stream&#x27;, this.readStop);
    return 0;
  }
  this._stream.pause();
  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_.prototype.setStream" id="apidoc.element.spdy.handle.super_.prototype.setStream">
        function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>setStream
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setStream(stream) {
  assert(this._stream === null, &#x27;Can\&#x27;t set stream two times&#x27;);
  this._stream = stream;

  this.emit(&#x27;stream&#x27;, stream);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
handle.assignClientRequest(req);

// Create stream only once `req.end()` is called
var self = this;
handle.once(&#x27;needStream&#x27;, function() {
  if (state.connection === null) {
    self.once(&#x27;_connect&#x27;, function() {
      handle.<span class="apidocCodeKeywordSpan">setStream</span>(self._createStream(req, handle));
    });
  } else {
    handle.setStream(self._createStream(req, handle));
  }
});

// Yes, it is in reverse
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_.prototype.shutdown" id="apidoc.element.spdy.handle.super_.prototype.shutdown">
        function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>shutdown
        <span class="apidocSignatureSpan">(req)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shutdown(req) {
  var wrap = this._queueReq(&#x27;shutdown&#x27;, req);

  if (!this._stream) {
    this.once(&#x27;stream&#x27;, function() {
      this._shutdown(wrap);
    });
    return 0;
  }

  return this._shutdown(wrap);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Handle.prototype._closeCallback = function _closeCallback(callback) {
var state = this._spdyState;
var stream = state.stream;

if (state.ending) {
  // The .end() method of the stream may be called by us or by the
  // .<span class="apidocCodeKeywordSpan">shutdown</span>() method in our super-class. If the latter has already been
  // called, then calling the .end() method below will have no effect, with
  // the result that the callback will never get executed, leading to an ever
  // so subtle memory leak.
  if (stream._writableState.finished) {
    // NOTE: it is important to call `setImmediate` instead of `nextTick`,
    // since this is how regular `handle.close()` works in node.js core.
    //
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_.prototype.writeAsciiString" id="apidoc.element.spdy.handle.super_.prototype.writeAsciiString">
        function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>writeAsciiString
        <span class="apidocSignatureSpan">(req, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeAsciiString(req, data) {
  return this.writeEnc(req, data, &#x27;ascii&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_.prototype.writeBinaryString" id="apidoc.element.spdy.handle.super_.prototype.writeBinaryString">
        function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>writeBinaryString
        <span class="apidocSignatureSpan">(req, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeBinaryString(req, data) {
  return this.writeEnc(req, data, &#x27;binary&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_.prototype.writeBuffer" id="apidoc.element.spdy.handle.super_.prototype.writeBuffer">
        function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>writeBuffer
        <span class="apidocSignatureSpan">(req, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeBuffer(req, data) {
  return this.writeEnc(req, data, null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_.prototype.writeEnc" id="apidoc.element.spdy.handle.super_.prototype.writeEnc">
        function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>writeEnc
        <span class="apidocSignatureSpan">(req, data, enc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeEnc(req, data, enc) {
  var wrap = this._queueReq(&#x27;write&#x27;, req);

  if (!this._stream) {
    this.once(&#x27;stream&#x27;, function() {
      this._writeEnc(wrap, req, data, enc);
    });

    return 0;
  }

  return this._writeEnc(wrap, req, data, enc);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_.prototype.writeLatin1String" id="apidoc.element.spdy.handle.super_.prototype.writeLatin1String">
        function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>writeLatin1String
        <span class="apidocSignatureSpan">(req, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeLatin1String(req, data) {
  return this.writeEnc(req, data, &#x27;binary&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_.prototype.writeUcs2String" id="apidoc.element.spdy.handle.super_.prototype.writeUcs2String">
        function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>writeUcs2String
        <span class="apidocSignatureSpan">(req, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeUcs2String(req, data) {
  return this.writeEnc(req, data, &#x27;ucs2&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.handle.super_.prototype.writeUtf8String" id="apidoc.element.spdy.handle.super_.prototype.writeUtf8String">
        function <span class="apidocSignatureSpan">spdy.handle.super_.prototype.</span>writeUtf8String
        <span class="apidocSignatureSpan">(req, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeUtf8String(req, data) {
  return this.writeEnc(req, data, &#x27;utf8&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.request" id="apidoc.module.spdy.request">module spdy.request</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.request.onNewListener" id="apidoc.element.spdy.request.onNewListener">
        function <span class="apidocSignatureSpan">spdy.request.</span>onNewListener
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onNewListener(type) {
  var req = this;

  if (type !== &#x27;push&#x27;)
    return;

  // Not first listener
  if (req.listeners(&#x27;push&#x27;).length !== 0)
    return;

  if (!req.socket) {
    req.on(&#x27;socket&#x27;, function() {
      attachPush(req);
    });
    return;
  }

  attachPush(req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.response" id="apidoc.module.spdy.response">module spdy.response</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.response.end" id="apidoc.element.spdy.response.end">
        function <span class="apidocSignatureSpan">spdy.response.</span>end
        <span class="apidocSignatureSpan">(data, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function end(data, encoding, callback) {
  if (!this._headerSent)
    this.writeHead(this.statusCode);

  if (!this.socket._handle)
    return;

  // Compatibility with Node.js core
  this.finished = true;

  var self = this;
  var handle = this.socket._handle;
  handle._spdyState.ending = true;
  this.socket.end(data, encoding, function() {
    self.constructor.prototype.end.call(self, &#x27;&#x27;, &#x27;utf8&#x27;, callback);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      autoSpdy31: false
    }
  }
};

var server = spdy.createServer(options, function(req, res) {
  res.writeHead(200);
  res.<span class="apidocCodeKeywordSpan">end</span>(&#x27;hello world!&#x27;);
});

server.listen(3000);
```

Client:
```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.response.push" id="apidoc.element.spdy.response.push">
        function <span class="apidocSignatureSpan">spdy.response.</span>push
        <span class="apidocSignatureSpan">(path, headers, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function push(path, headers, callback) {
  var frame = {
    path: path,
    method: headers.method ? headers.method.toString() : &#x27;GET&#x27;,
    status: headers.status ? parseInt(headers.status, 10) : 200,
    host: this._req.headers.host,
    headers: headers.request,
    response: headers.response
  };

  var stream = this.spdyStream;
  return stream.pushPromise(frame, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Push streams

It is possible to initiate [PUSH_PROMISE][5] to send content to clients _before_
the client requests it.

```javascript
spdy.createServer(options, function(req, res) {
var stream = res.<span class="apidocCodeKeywordSpan">push</span>(&#x27;/main.js&#x27;, {
  status: 200, // optional
  method: &#x27;GET&#x27;, // optional
  request: {
    accept: &#x27;*/*&#x27;
  },
  response: {
    &#x27;content-type&#x27;: &#x27;application/javascript&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.response.writeContinue" id="apidoc.element.spdy.response.writeContinue">
        function <span class="apidocSignatureSpan">spdy.response.</span>writeContinue
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeContinue(callback) {
  if (this.socket._handle)
    this.socket._handle._spdyState.stream.respond(100, {}, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    stream.end();
  });

  server.on(&#x27;checkContinue&#x27;, function(req, res) {
    req.on(&#x27;end&#x27;, function() {
      res.<span class="apidocCodeKeywordSpan">writeContinue</span>();
      res.end(&#x27;response&#x27;);
    });
    req.resume();
  });
});

it(&#x27;should send PUSH_PROMISE&#x27;, function(done) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.response.writeHead" id="apidoc.element.spdy.response.writeHead">
        function <span class="apidocSignatureSpan">spdy.response.</span>writeHead
        <span class="apidocSignatureSpan">(statusCode, reason, obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeHead(statusCode, reason, obj) {
  var headers;

  if (typeof reason === &#x27;string&#x27;) {
    // writeHead(statusCode, reasonPhrase[, headers])
    this.statusMessage = reason;
  } else {
    // writeHead(statusCode[, headers])
    this.statusMessage =
      this.statusMessage || &#x27;unknown&#x27;;
    obj = reason;
  }
  this.statusCode = statusCode;

  if (this._headers) {
    // Slow-case: when progressive API and header fields are passed.
    if (obj) {
      var keys = Object.keys(obj);
      for (var i = 0; i &#x3c; keys.length; i++) {
        var k = keys[i];
        if (k) this.setHeader(k, obj[k]);
      }
    }
    // only progressive api is used
    headers = this._renderHeaders();
  } else {
    // only writeHead() called
    headers = obj;
  }

  if (statusCode === 204 || statusCode === 304 ||
      (100 &#x3c;= statusCode &#x26;&#x26; statusCode &#x3c;= 199)) {
    // RFC 2616, 10.2.5:
    // The 204 response MUST NOT include a message-body, and thus is always
    // terminated by the first empty line after the header fields.
    // RFC 2616, 10.3.5:
    // The 304 response MUST NOT contain a message-body, and thus is always
    // terminated by the first empty line after the header fields.
    // RFC 2616, 10.1 Informational 1xx:
    // This class of status code indicates a provisional response,
    // consisting only of the Status-Line and optional headers, and is
    // terminated by an empty line.
    this._hasBody = false;
  }

  // don&#x27;t keep alive connections where the client expects 100 Continue
  // but we sent a final status; they may put extra bytes on the wire.
  if (this._expect_continue &#x26;&#x26; !this._sent100) {
    this.shouldKeepAlive = false;
  }

  // Implicit headers sent!
  this._header = true;
  this._headerSent = true;

  if (this.socket._handle)
    this.socket._handle._spdyState.stream.respond(this.statusCode, headers);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      // **optional** if true - server will send 3.1 frames on 3.0 *plain* spdy
      autoSpdy31: false
    }
  }
};

var server = spdy.createServer(options, function(req, res) {
  res.<span class="apidocCodeKeywordSpan">writeHead</span>(200);
  res.end(&#x27;hello world!&#x27;);
});

server.listen(3000);
```

Client:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.spdy.server" id="apidoc.module.spdy.server">module spdy.server</a></h1>


    <h2>
        <a href="#apidoc.element.spdy.server.PlainServer" id="apidoc.element.spdy.server.PlainServer">
        function <span class="apidocSignatureSpan">spdy.server.</span>PlainServer
        <span class="apidocSignatureSpan">(options, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(options, handler) {
  this._init(base, options, handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.server.Server" id="apidoc.element.spdy.server.Server">
        function <span class="apidocSignatureSpan">spdy.server.</span>Server
        <span class="apidocSignatureSpan">(options, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(options, handler) {
  this._init(base, options, handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.spdy.server.create" id="apidoc.element.spdy.server.create">
        function <span class="apidocSignatureSpan">spdy.server.</span>create
        <span class="apidocSignatureSpan">(base, options, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(base, options, handler) {
  if (typeof base === &#x27;object&#x27;) {
    handler = options;
    options = base;
    base = null;
  }

  if (base)
    return instantiate(base).create(options, handler);

  if (options.spdy &#x26;&#x26; options.spdy.plain)
    return exports.PlainServer.create(options, handler);
  else
    return exports.Server.create(options, handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

server.listen(fixtures.port, function() {
  var socket = (plain ? net : tls).connect({
    rejectUnauthorized: false,
    port: fixtures.port,
    NPNProtocols: [ npn ]
  }, function() {
    client = transport.connection.<span class="apidocCodeKeywordSpan">create</span>(socket, {
      protocol: protocol,
      isServer: false
    });
    client.start(version);
    done();
  });
});
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
